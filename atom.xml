<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jiaxing的个人主页</title>
  
  
  <link href="https://wilsssssssson.github.io/atom.xml" rel="self"/>
  
  <link href="https://wilsssssssson.github.io/"/>
  <updated>2025-05-08T03:25:34.992Z</updated>
  <id>https://wilsssssssson.github.io/</id>
  
  <author>
    <name>Jiaxing Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Visual-RFT论文阅读-视觉慢推理</title>
    <link href="https://wilsssssssson.github.io/2025/05/07/Visual-RFT%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E8%A7%86%E8%A7%89%E6%85%A2%E6%8E%A8%E7%90%86/"/>
    <id>https://wilsssssssson.github.io/2025/05/07/Visual-RFT%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E8%A7%86%E8%A7%89%E6%85%A2%E6%8E%A8%E7%90%86/</id>
    <published>2025-05-07T09:29:50.000Z</published>
    <updated>2025-05-08T03:25:34.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Visual Reinforcement Fine-Tuning（Visual-RFT） 是一种将强化学习应用于视觉任务的方法，旨在提升大视觉语言模型（LVLMs）的视觉感知和推理能力。它通过让 LVLMs 生成包含推理和答案的多响应，利用任务特定的可验证奖励函数（如检测任务的 IoU 奖励、分类任务的准确率奖励），借助策略优化算法更新模型。</p><p>文章的“Methodology”部分主要介绍了Visual - RFT所涉及的基础概念、方法框架以及关键组成部分，具体内容如下：</p><ol><li><strong>预备知识</strong><ul><li><strong>可验证奖励的强化学习（RLVR）</strong>：是一种用于提升语言模型在具有客观可验证结果任务（如数学和编程）中表现的训练方法。与传统的基于人类反馈的强化学习（RLHF）不同，RLVR不依赖训练的奖励模型，而是使用直接验证函数来评估正确性。给定输入问题$q$，策略模型$\pi_{\theta}$生成响应$o$并获得可验证奖励。其优化目标为：<br>[max <em>{\pi</em>{\theta}} \mathbb{E}<em>{o \sim \pi</em>{\theta}(q)}\left[R_{RLVR}(q, o)\right]&#x3D;\left[R(q, o)-\beta KL\left[\pi_{\theta}(o | q) | \pi_{ref }(o | q)\right]\right]]<br>其中，$\pi_{ref}$是优化前的参考模型，$R$是可验证奖励函数，$\beta$是控制KL散度的超参数。可验证奖励函数$R$根据问题和输出对$(q, o)$判断预测与真实答案是否一致，若一致则$R(q, o)&#x3D;1$，否则为$0$。</li><li><strong>DeepSeek R1 - Zero和GRPO</strong>：DeepSeek R1 - Zero算法通过Group Relative Policy Optimization（GRPO）框架，仅利用强化学习进行训练，消除了对监督微调（SFT）的依赖。对于给定问题$q$，GRPO从当前策略$\pi_{\theta_{old}}$生成$G$个不同的响应${o_{1}, o_{2},…, o_{G}}$，然后根据这些响应采取行动并获得奖励${r_{1}, r_{2},…, r_{G}}$。通过计算奖励的均值和标准差进行归一化，以确定这些响应的相对质量：<br>$A_{i}&#x3D;\frac{r_{i}-mean\left(\left{r_{1},…, r_{G}\right}\right)}{std\left(\left{r_{1},…, r_{G}\right}\right)}$<br>其中，$A_{i}$代表第$i$个答案的相对质量。GRPO鼓励模型在组内选择奖励值高的更好答案。</li></ul></li><li><strong>Visual - RFT</strong><ul><li><strong>整体框架</strong>：Visual - RFT的框架中，多模态输入数据由图像和问题组成。策略模型$\pi_{6}$根据输入输出推理过程并生成一组响应。每个响应通过可验证奖励函数计算奖励，在对每个输出的奖励进行分组计算后，评估每个响应的质量并用于更新策略模型。为保证策略模型训练的稳定性，Visual - RFT使用KL散度限制策略模型与参考模型之间的差异。</li><li><strong>视觉感知中的可验证奖励</strong><ul><li><strong>检测任务中的IoU奖励</strong>：在检测任务中，模型输出包含边界框（bbox）和相应置信度。奖励函数需考虑用于评估平均精度均值（mAP）的交并比（IoU）指标。首先对模型输出的边界框按置信度排序为${b_{1}, b_{2},…, b_{n}}$，并与真实边界框${b_{1}^{g}, b_{2}^{g},…, b_{m}^{g}}$匹配计算IoU，设置IoU阈值$\tau$，低于阈值的边界框视为无效，未匹配的边界框IoU为0。匹配后得到每个框的IoU和置信度${iou_{1}:c_{1}, iou_{2}:c_{2},…, iou_{n}:c_{n}}$ ，由此构建奖励$R_{d}$，它由三部分组成：</li></ul></li></ul></li></ol><p>[R_{d}&#x3D;R_{IoU }+R_{conf }+R_{format }]<br>其中，$R_{IoU}$是模型输出所有边界框的平均IoU：<br>[R_{IoU}&#x3D;\frac{iou_{1}+iou_{2}+…+iou_{n}}{n}]<br>置信度奖励$R_{conf}$与IoU相关，对于每个边界框，若$iou$非零（表示匹配成功），则该单个框的置信度奖励$r_{ci}$为预测置信度；若$iou$为零（表示匹配失败），则$r_{ci}$为$1 - c_{i}$。模型输出的整体置信度奖励$R_{conf}$是所有边界框置信度奖励的平均值：<br>[R_{conf }&#x3D;\frac{\sum_{i&#x3D;1}^{n} r_{c i}}{n}]<br>格式奖励$R_{format}$用于强制模型预测符合<think>和<answer>所需的HTML标签格式。<br>        - <strong>分类任务中的CLS奖励</strong>：在分类任务中，奖励函数由准确率奖励$R_{acc}$和格式奖励$R_{format}$组成。准确率奖励通过比较模型输出类别与真实类别来确定，分类正确为1，错误为0：<br>[R_{cls }&#x3D;R_{acc }+R_{format }]<br>    - <strong>数据准备</strong>：为在各种视觉感知任务上训练Visual - RFT，需构建多模态训练数据集。与DeepSeek R1类似，Visual - RFT设计了提示格式，引导模型在给出最终答案前输出推理过程。检测和分类任务使用的提示格式分别规定了输出的具体要求，如检测任务需按特定格式输出检测对象的边界框、置信度及推理过程；分类任务需按格式输出植物物种识别的推理过程和结果。在训练过程中，利用格式奖励引导模型以结构化格式输出推理过程和最终答案，推理过程是模型在强化微调中自我学习和改进的关键，而答案确定的奖励则指导模型的优化方向。 </p><img src="/2025/05/07/Visual-RFT%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E8%A7%86%E8%A7%89%E6%85%A2%E6%8E%A8%E7%90%86/framework.png" class="" title="框架图">]]></content>
    
    
    <summary type="html">类似deepseek的推理模型并不能很好地处理多模态的任务类型，本文提出一种视觉增强的强化学习，增强模型在视觉推理方面的能力</summary>
    
    
    
    <category term="deeplearning" scheme="https://wilsssssssson.github.io/categories/deeplearning/"/>
    
    
    <category term="deeplearning" scheme="https://wilsssssssson.github.io/tags/deeplearning/"/>
    
    <category term="slow-reasoning" scheme="https://wilsssssssson.github.io/tags/slow-reasoning/"/>
    
  </entry>
  
  <entry>
    <title>发起请求和相应请求导致的bug-取消请求方法</title>
    <link href="https://wilsssssssson.github.io/2025/05/06/%E5%8F%91%E8%B5%B7%E8%AF%B7%E6%B1%82%E5%92%8C%E7%9B%B8%E5%BA%94%E8%AF%B7%E6%B1%82%E5%AF%BC%E8%87%B4%E7%9A%84bug-%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95/"/>
    <id>https://wilsssssssson.github.io/2025/05/06/%E5%8F%91%E8%B5%B7%E8%AF%B7%E6%B1%82%E5%92%8C%E7%9B%B8%E5%BA%94%E8%AF%B7%E6%B1%82%E5%AF%BC%E8%87%B4%E7%9A%84bug-%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95/</id>
    <published>2025-05-06T09:16:37.000Z</published>
    <updated>2025-05-06T09:58:34.899Z</updated>
    
    <content type="html"><![CDATA[<h1 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h1><h2 id="问题存在"><a href="#问题存在" class="headerlink" title="问题存在"></a>问题存在</h2><p>首先来看bug发生的场景：现在有一个搜索框，需要实现一个功能，搜索联想，当用户输入不同的关键词，下方可以出现不同的联想。</p><p>现在用户输入了一个1，联想下返回是11，用户输入2，联想返回是2，以此类推。这种情况下网络情况我们是不能保证的，所以可能出现不同相应返回的时间不一致的情况，如果2的返回早于一的返回，那么用户得到的搜索关键词，可能是上一次发出的，从而导致bug。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dosomething</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//将返回替换到联想栏当中</span></span><br><span class="line">&#125;</span><br><span class="line">input.<span class="property">oninput</span> = <span class="title function_">async</span>()=&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = fetch.<span class="title function_">get</span>(&#123;</span><br><span class="line">        <span class="string">&#x27;http···？key=&#x27;</span>+input.<span class="property">value</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        res.<span class="title function_">json</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">dosomething</span>(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="错误的解决方法"><a href="#错误的解决方法" class="headerlink" title="错误的解决方法"></a>错误的解决方法</h2><p>防抖，防抖并不能解决这个问题，当我的两次输入超过了防抖设置的时间间隔，两次请求同同样都会发出，这个时候我们还是不能控制接受到的时间</p><h2 id="正确的解决方法"><a href="#正确的解决方法" class="headerlink" title="正确的解决方法"></a>正确的解决方法</h2><p>本质上就是要取消上一次发出去的请求，在http请求头里有一个<strong>signal</strong>字段，这个字段可以用来传递实时通信的控制信号，比如会话的建立、结束、媒体流的控制等指令<br>在fetch api中，可以在请求头字段添加一个signal字段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cosnt controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"><span class="keyword">const</span> response = fetch.<span class="title function_">get</span>(&#123;</span><br><span class="line">    <span class="string">&#x27;http···？key=&#x27;</span>+input.<span class="property">value</span>，</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">signal</span>: controller.<span class="property">signal</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过这种方法我们就可以控制某一次的请求的中止，所以现在的核心方法就是获取上一次请求的控制器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dosomething</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//将返回替换到联想栏当中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将控制器设为当前作用域的全局变量</span></span><br><span class="line"><span class="keyword">const</span> controller = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">input.<span class="property">oninput</span> = <span class="title function_">async</span>()=&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(controller)&#123;</span><br><span class="line">        controller.<span class="title function_">abort</span>()</span><br><span class="line">    &#125;<span class="comment">//取消上一次的请求。</span></span><br><span class="line">    controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line">    <span class="keyword">const</span> response = fetch.<span class="title function_">get</span>(&#123;</span><br><span class="line">        <span class="string">&#x27;http···？key=&#x27;</span>+input.<span class="property">value</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        res.<span class="title function_">json</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">dosomething</span>(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">网络请求当中，发出请求和响应时间不一致可能导致bug，本博客给出一种解决方法</summary>
    
    
    
    <category term="frontend" scheme="https://wilsssssssson.github.io/categories/frontend/"/>
    
    
    <category term="javascript" scheme="https://wilsssssssson.github.io/tags/javascript/"/>
    
    <category term="httpRequest" scheme="https://wilsssssssson.github.io/tags/httpRequest/"/>
    
  </entry>
  
  <entry>
    <title>PHYBench论文阅读-新的物理题求解评估指标</title>
    <link href="https://wilsssssssson.github.io/2025/04/26/PHYBench%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E6%96%B0%E7%9A%84%E7%89%A9%E7%90%86%E9%A2%98%E6%B1%82%E8%A7%A3%E8%AF%84%E4%BC%B0%E6%8C%87%E6%A0%87/"/>
    <id>https://wilsssssssson.github.io/2025/04/26/PHYBench%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E6%96%B0%E7%9A%84%E7%89%A9%E7%90%86%E9%A2%98%E6%B1%82%E8%A7%A3%E8%AF%84%E4%BC%B0%E6%8C%87%E6%A0%87/</id>
    <published>2025-04-26T01:57:14.000Z</published>
    <updated>2025-05-06T11:45:08.634Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="论文提出PHYBench这一用于评估大语言模型物理推理能力的高质量基准测试，包含500道基于现实物理场景的问题，涵盖多个物理领域和难度级别。同时提出表达式编辑距离（EED）分数这一评估指标，通过与人类专家对比实验发现，即使是最先进的推理模型在物理推理任务上也与人类存在显著差距，凸显模型在物理感知和稳健推理方面的局限。"><a href="#论文提出PHYBench这一用于评估大语言模型物理推理能力的高质量基准测试，包含500道基于现实物理场景的问题，涵盖多个物理领域和难度级别。同时提出表达式编辑距离（EED）分数这一评估指标，通过与人类专家对比实验发现，即使是最先进的推理模型在物理推理任务上也与人类存在显著差距，凸显模型在物理感知和稳健推理方面的局限。" class="headerlink" title="论文提出PHYBench这一用于评估大语言模型物理推理能力的高质量基准测试，包含500道基于现实物理场景的问题，涵盖多个物理领域和难度级别。同时提出表达式编辑距离（EED）分数这一评估指标，通过与人类专家对比实验发现，即使是最先进的推理模型在物理推理任务上也与人类存在显著差距，凸显模型在物理感知和稳健推理方面的局限。"></a>论文提出<strong>PHYBench</strong>这一用于评估大语言模型物理推理能力的高质量基准测试，包含500道基于现实物理场景的问题，涵盖多个物理领域和难度级别。同时提出<strong>表达式编辑距离（EED）分数</strong>这一评估指标，通过与人类专家对比实验发现，即使是最先进的推理模型在物理推理任务上也与人类存在显著差距，凸显模型在物理感知和稳健推理方面的局限。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">## **PHYBench基准测试介绍**</span><br><span class="line">- 包含500道物理问题，涵盖多领域和多难度</span><br><span class="line">- 问题基于现实场景，需推导符号表达式</span><br><span class="line">## **评估指标**</span><br><span class="line">- 准确性指标：判断模型答案与正确答案是否完全一致</span><br><span class="line">- EED分数指标：计算表达式树编辑距离衡量相似性</span><br><span class="line">## **实验设置与结果**</span><br><span class="line">- 测试多种模型，包括前沿和常用模型</span><br><span class="line">- 人类专家准确率61.9%，EED分数70.4，远超模型</span><br><span class="line">## **错误分析**</span><br><span class="line">- 物理感知错误：对物理过程理解不足，如误解运动关系</span><br><span class="line">- 稳健推理错误：推理过程不一致，解方程困难</span><br></pre></td></tr></table></figure><hr><h3 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h3><ol><li>大语言模型（LLMs）推理能力提升，但现有基准测试在评估其物理感知和推理能力方面存在不足。</li><li>问题包括推理任务过于简化、问题过度抽象、缺乏精确评估指标。</li></ol><h3 id="PHYBench基准测试"><a href="#PHYBench基准测试" class="headerlink" title="PHYBench基准测试"></a>PHYBench基准测试</h3><ol><li><strong>构成与难度</strong>：包含500道精心策划的物理问题，涵盖力学、电磁学、热力学等多个领域，难度从高中到本科及物理竞赛水平。</li><li><strong>数据集整理</strong>：问题改编自物理练习，由北大物理学院学生参与贡献和完善，经过多轮审查、测试和优化，确保问题质量和规范性。</li><li><strong>评估指标</strong><ul><li><strong>准确性（Accuracy）</strong>：传统的判断模型答案是否正确的指标，以二进制（正确&#x2F;错误）计分。</li><li><strong>表达式编辑距离（EED）分数</strong>：基于表达式树编辑距离，计算模型生成答案与正确答案的相似度，能更细致地反映模型推理的正确性，分数范围为0 - 100分。</li></ul></li></ol><table><thead><tr><th>指标</th><th>计算方式</th><th>特点</th></tr></thead><tbody><tr><td>准确性</td><td>模型答案与正确答案完全一致计100分，否则计0分</td><td>简单直观，但无法区分部分正确情况</td></tr><tr><td>EED分数</td><td>通过计算表达式树编辑距离，根据相对编辑距离确定分数</td><td>能反映模型答案与正确答案的相似程度，对部分正确答案也能计分</td></tr></tbody></table><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><ol><li><strong>实验设置</strong>：测试多种具有代表性的LLMs，包括前沿模型和广泛应用的模型，使用准确性和EED分数两个指标评估，本地运行模型设置特定推理参数。</li><li><strong>人类基线</strong>：招募81名北大物理学院学生参与答题，平均准确率为61.9% ± 2.1%，EED分数为70.4 ± 1.8，在两个指标上均显著优于所有评估的LLMs。</li><li><strong>主要结果</strong><ul><li>即使是最先进的推理模型在物理推理任务上表现也有限，如Gemini 2.5 pro准确率为36.9%，EED分数为49.5，远低于人类基线。</li><li>EED分数在评估模型性能时，数值分布更广泛，统计不确定性更小，平均样本效率比准确性指标提高304%。</li></ul></li><li><strong>模型在不同领域的表现</strong><ul><li>定义绝对优势和相对优势两个指标，分析模型在不同物理领域的表现。</li><li>不同模型在不同领域各有优劣，如传统模型在力学领域表现较差，推理专用模型在力学领域表现相对较好，热力学问题能体现推理和非推理模型的差距。</li></ul></li></ol><h3 id="错误分析"><a href="#错误分析" class="headerlink" title="错误分析"></a>错误分析</h3><ol><li><strong>物理感知错误</strong>：模型对物理过程理解不足和建模能力欠缺，导致对物理场景的错误判断，影响最终答案，32B模型在这方面表现尤其差。</li><li><strong>稳健推理错误</strong>：模型在长而复杂的推理过程中难以保持一致性，解方程存在困难，物理问题的长程符号推理对当前模型是重大挑战。</li><li><strong>EED指标的作用</strong>：EED分数能有效捕捉物理感知和稳健推理阶段的错误，通过量化中间过程的差异，评估模型的推理能力。</li></ol><h3 id="研究结论"><a href="#研究结论" class="headerlink" title="研究结论"></a>研究结论</h3><ol><li>PHYBench为评估LLMs的物理推理能力提供了全面的基准测试，EED分数能更细致地评估模型推理过程。</li><li>实验结果表明当前LLMs在物理感知和稳健推理方面存在基本限制，与人类专家有较大差距，未来发展面临挑战和机遇。</li></ol><hr><p><strong>问题1：PHYBench与其他推理基准测试相比有哪些独特之处？</strong><br>答案：PHYBench包含500道高质量问题，涵盖多种物理领域和难度级别，基于现实物理场景。其评估指标除了准确性还有EED分数，能更细致评估模型推理能力。其他基准测试存在任务简化、问题抽象、评估指标单一等问题，如GSM8K数据规模为8.5K，难度为小学级别，采用准确率和二进制评分；OlympiadBench有8K道题，为竞赛级别，答案类型为受限的LATEX表达式，采用准确率和二进制评分。</p><p><strong>问题2：EED分数相较于传统二进制评分的优势体现在哪些方面？</strong><br>答案：EED分数基于表达式树编辑距离，能有效捕捉模型答案与正确答案的相似度，对于部分正确的答案也能给出非零分数，更好地反映模型的能力。而传统二进制评分在任务过难或过易时，分数易集中在极高或极低水平，无法有效区分模型能力。例如在低分段，EED评分的鉴别力和线性度更高，信息容量更大，平均样本效率比准确性指标提高304%。</p><p><strong>问题3：从实验结果来看，不同类型模型在物理推理任务上的表现有何差异？</strong><br>答案：推理专用模型通常优于通用语言模型，如Gemini 2.5 pro作为表现较好的模型，准确率为36.9%，EED分数为49.5；而一些通用模型如DeepSeek-V3、GPT-4.1和Claude 3.7 Sonnet的准确率分别为13.6%、12.9%和13.2%。32B模型如DeepSeek-Distill-32B和QwQ-32B在PHYBench上表现较弱，准确率分别为2.6%和1.2%，EED分数分别为4.5和3.2。 </p><p><em><strong>出题要求核心：</strong></em></p><ul><li><strong>基于文本的表述</strong>：所有问题必须仅通过文本描述就能求解，不依赖多模态输入。</li><li><strong>严格的符号答案</strong>：答案必须是单一、明确的符号表达式（例如，$2mg + \frac{4mv_{0}^{2}}{l}$ ）。我们允许符号表达式有不同的等价形式（例如，因式分解或重新排列后的形式）。但答案中不接受方程（例如，$\frac{T}{m} - 2g &#x3D; \frac{v_{0}^{2}}{l}$ ）或浮点近似值。</li><li><strong>表述明确</strong>：问题表述必须严谨精确，避免歧义。</li></ul><p>在本节中，我们将介绍表达式编辑距离分数（EED分数）的计算流程和详细信息。这是一种自动化、无模型依赖的评估指标，旨在评估人工智能生成的解决方案的正确性。</p><p>EED分数通过计算表达式树编辑距离来评估两个符号表达式之间的相似性。这个距离表示将一个树状结构的表达式转换为另一个所需的最少节点级编辑操作（插入、删除和更新）次数。</p><p>为了表述清晰，在接下来的讨论中，我们用“gt”作为“正确答案（ground truth）”的缩写，用“gen”表示“模型生成的答案”。</p><p>EED分数的计算包含几个步骤。首先，我们将gt和gen表达式从LaTeX格式转换为与SymPy兼容的形式。然后，我们使用<code>simplify()</code>函数来验证它们是否等价，该函数会将每个表达式转换为简化且结构一致的格式。</p><p>因此，在进一步计算EED分数之前，我们可以使用一个简单的等价标准进行基本的二进制计分，定义如下：<br>[score_{Bin}&#x3D;\begin{cases}100, &amp; \text{如果 } simplify(gt)\equiv simplify(gen) \ 0, &amp; \text{否则}\end{cases}]</p><p>随后，我们将简化后的SymPy表达式转换为树结构，并使用扩展的Zhang - Shasha算法[3]计算它们的最小编辑距离。最终的EED分数由一个基于相对编辑距离（编辑距离与正确答案树中节点总数的比值）的分段线性函数确定：<br>[r &#x3D; \frac{Distance(T_{gt}, T_{gen})}{Size(T_{gt})}, score &#x3D;\begin{cases}100, &amp; \text{如果 } r &#x3D; 0 \text{（完全匹配）}\ 60 - 100r, &amp; \text{如果 } 0 &lt; r &lt; 0.6\ 0, &amp; \text{如果 } r &gt; 0.6\end{cases}]</p><p>此外，我们的算法扩展了基本的三种树编辑操作，增加了子树插入和删除操作。对于较大的子树（节点数大于5），这些操作的成本系数降低为60%，明显低于逐节点进行编辑的成本。计分函数“60 - 100r”的设定是为了确保完全错误的输出得分为0分，而对于接近正确的模型生成答案给予60分的基础分。</p><p>采用EED分数而非传统二进制计分的主要动机是为了更好地捕捉模型解决方案的正确程度。即使生成的答案有细微差异，比如小的计算错误或系数错误，这也表明模型对底层物理知识有部分理解，而非完全误解。附录A.1中提供了关于我们评估指标更详细的解释和示例。 </p>]]></content>
    
    
    <summary type="html">论文阅读-北大发布的物理题求解评价新指标</summary>
    
    
    
    <category term="deeplearning" scheme="https://wilsssssssson.github.io/categories/deeplearning/"/>
    
    
    <category term="deeplearning" scheme="https://wilsssssssson.github.io/tags/deeplearning/"/>
    
    <category term="physics" scheme="https://wilsssssssson.github.io/tags/physics/"/>
    
  </entry>
  
  <entry>
    <title>LLaVA—cot</title>
    <link href="https://wilsssssssson.github.io/2025/03/17/LLaVA%E2%80%94cot/"/>
    <id>https://wilsssssssson.github.io/2025/03/17/LLaVA%E2%80%94cot/</id>
    <published>2025-03-17T07:51:28.000Z</published>
    <updated>2025-04-29T09:28:13.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LLaVA-CoT：让视觉语言模型逐步推理的创新探索"><a href="#LLaVA-CoT：让视觉语言模型逐步推理的创新探索" class="headerlink" title="LLaVA-CoT：让视觉语言模型逐步推理的创新探索"></a>LLaVA-CoT：让视觉语言模型逐步推理的创新探索</h1><h2 id="一、研究动机"><a href="#一、研究动机" class="headerlink" title="一、研究动机"></a>一、研究动机</h2><p>大语言模型（LLMs）在推理能力上取得显著进展，然而当前视觉语言模型（VLMs）在复杂视觉问答任务中，难以进行系统和结构化的推理，经常出现错误或幻觉输出。这主要是因为现有VLMs推理过程缺乏系统性和结构化，它们在未充分梳理问题和信息时就开始作答，且推理过程容易偏离逻辑，导致结论不准确。为解决这些问题，研究团队提出LLaVA-CoT，旨在实现VLMs的自主多阶段推理，提升其在复杂任务中的表现。</p><h2 id="二、方法介绍"><a href="#二、方法介绍" class="headerlink" title="二、方法介绍"></a>二、方法介绍</h2><h3 id="（一）结构化推理阶段"><a href="#（一）结构化推理阶段" class="headerlink" title="（一）结构化推理阶段"></a>（一）结构化推理阶段</h3><p>LLaVA-CoT将答案生成过程分解为四个结构化推理阶段，每个阶段都有独特的功能和目标。</p><ol><li><strong>总结阶段</strong>：模型对问题进行高屋建瓴的概括，梳理出解决问题的核心思路和关键步骤，为后续推理指明方向。面对“计算图中两种水果数量之差”的问题，模型在总结阶段会确定先识别并统计两种水果的数量，再进行减法运算的解题思路。</li><li><strong>图像描述阶段</strong>：当存在图像时，模型聚焦于与问题相关的视觉元素，详细描述图像内容，帮助理解多模态输入。针对上述水果问题，会描述图像中水果的种类、颜色、大致位置等信息。</li><li><strong>推理阶段</strong>：基于总结和图像描述，模型进行严谨的逻辑推理，逐步推导得出初步答案。在水果数量差问题中，依据统计的水果数量进行计算，展示推理过程。</li><li><strong>结论阶段</strong>：综合前面的推理，模型给出最终答案。答案形式会根据用户需求调整，简洁或详细解释均可。</li></ol><h3 id="（二）数据准备与模型训练"><a href="#（二）数据准备与模型训练" class="headerlink" title="（二）数据准备与模型训练"></a>（二）数据准备与模型训练</h3><p>由于现有VQA数据集无法满足LLaVA-CoT的训练需求，研究团队整合多个常用VQA数据集，构建了包含99k图像QA对的LLaVA-CoT-100k数据集。利用GPT-4o生成详细的推理过程，包括四个推理阶段的内容，并将其编译到数据集中。以Llama-3.2-11B-Vision-Instruct为基础模型，使用该数据集进行全参数微调，在单节点8H100 GPUs上完成训练。</p><h3 id="（三）阶段级束搜索方法"><a href="#（三）阶段级束搜索方法" class="headerlink" title="（三）阶段级束搜索方法"></a>（三）阶段级束搜索方法</h3><p>为提升模型推理能力，LLaVA-CoT采用阶段级束搜索方法。在每个推理阶段，随机采样N个响应（如先随机选2个），让模型依据特定标准评估这些响应。在总结阶段，好的总结应突出解题思路；图像描述阶段，描述要精准全面；推理阶段，需深入分析每个答案的差异，选择推理更合理的；结论阶段，结论要与推理一致且不能拒绝回答问题。模型选择最优响应进入下一阶段，重复此过程直至完成所有阶段，确保最终输出质量。</p><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><h3 id="（一）推理阶段划分依据"><a href="#（一）推理阶段划分依据" class="headerlink" title="（一）推理阶段划分依据"></a>（一）推理阶段划分依据</h3><p>推理阶段的划分是基于对复杂问题解决过程的拆解。总结阶段是为了明确问题解决的方向和大致步骤，让模型对任务有整体认知；图像描述阶段针对多模态信息中的图像部分进行关键信息提取，为后续推理提供视觉依据；推理阶段基于前面的准备进行实质性的逻辑推导；结论阶段则是对整个推理过程的总结和输出，提供符合用户需求的答案。这种划分方式模仿人类解决复杂问题时的思维过程，使模型的推理更加系统和结构化。</p><h3 id="（二）阶段级束搜索优势"><a href="#（二）阶段级束搜索优势" class="headerlink" title="（二）阶段级束搜索优势"></a>（二）阶段级束搜索优势</h3><p>阶段级束搜索在质量控制和计算效率之间实现了良好平衡。与Best-of-N搜索相比，Best-of-N搜索生成N个完整答案后选择最优，评估过程较为粗糙，难以准确判断答案准确性。句子级束搜索在句子层面操作，过于细致，对于开放式问题难以有效评估响应质量。而阶段级束搜索在每个推理阶段进行筛选，能及时纠正推理方向，避免错误累积，在复杂推理任务中显著提高推理准确性，且没有大幅增加计算成本。在MMVet基准测试中，阶段级束搜索（束大小为4）相比无推理时间缩放的模型，性能提升明显。 </p>]]></content>
    
    
    <summary type="html">论文阅读-LLaVA-COT</summary>
    
    
    
    <category term="deeplearning" scheme="https://wilsssssssson.github.io/categories/deeplearning/"/>
    
    
    <category term="deeplearning" scheme="https://wilsssssssson.github.io/tags/deeplearning/"/>
    
    <category term="multimodal" scheme="https://wilsssssssson.github.io/tags/multimodal/"/>
    
  </entry>
  
  <entry>
    <title>多模态对齐</title>
    <link href="https://wilsssssssson.github.io/2025/03/07/%E5%A4%9A%E6%A8%A1%E6%80%81%E5%AF%B9%E9%BD%90/"/>
    <id>https://wilsssssssson.github.io/2025/03/07/%E5%A4%9A%E6%A8%A1%E6%80%81%E5%AF%B9%E9%BD%90/</id>
    <published>2025-03-07T09:51:43.000Z</published>
    <updated>2025-04-29T03:19:31.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>当前的多模态发展还未到达文本邻域一样成熟，将其分为以下几类</p><ul><li>编码器解码器架构<ul><li>原始数据集融合</li><li>层次特征融合</li><li>决策级融合</li></ul></li><li>注意力机制<ul><li>模态内自注意力</li><li>模态间交叉注意力</li><li>非局部注意力</li></ul></li><li>基于图神经网络的融合</li><li>基于生成神经网络的融合</li><li>其他</li></ul><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol><li><a href="#1">编码器解码器架构</a></li><li><a href="#2">注意力机制架构</a></li><li><a href="#3">基于图神经网络的融合</a></li><li><a href="#4">基于生成神经网络的融合</a></li><li><a href="#5">其他</a></li></ol><h1 id="编码器解码器架构"><a href="#编码器解码器架构" class="headerlink" title="编码器解码器架构"></a><h id='1'>编码器解码器架构<h></h1><h2 id="原始数据融合"><a href="#原始数据融合" class="headerlink" title="原始数据融合"></a><h id='1.1'>原始数据融合<h></h2><p>在这种融合中，每个模态的原始数据或从每个模态的独立预处理中获得的数据将在输入级别进行整合。然后，形成的多模态输入向量将被发送到一个编码器，用于提取高级特征。来自各个模态的数据在低级别（例如输入级别）进行融合，并且只应用一个编码器来提取多模态数据的高级特征</p><h2 id="层次特征融合"><a href="#层次特征融合" class="headerlink" title="层次特征融合"></a><h id='1.2'>层次特征融合<h></h2><p>由于DNN具有强大的层次表示学习能力，与原始数据级融合不同，许多工作使用设计良好的网络架构，迫使模型在不同级别融合多模态层次特征。这种融合方法的动机是，融合和聚合来自不同抽象级别的数据可以更好地利用从分层深度网络中提取的多级特征，从而共同提高模型的性能</p><h2 id="决策层融合融合"><a href="#决策层融合融合" class="headerlink" title="决策层融合融合"></a><h id='1.3'>决策层融合融合<h></h2><p>与上述分层特征融合策略不同，决策级融合相对简单，灵活性较低，但易于实现。该方法中的融合操作固定在单个子网络的解码器或分类器的末尾，这意味着在解码器的最后一层或倒数第二层交换交叉模态信息。它对多模态交互的可解释性有限。对于分类任务，最终的融合可以通过使用经典的多数投票或从多层感知器中学习的权重来实现。对于回归任务，通常会训练一个线性回归器来融合单个模态的预测。</p><h1 id="基于注意力机制的融合"><a href="#基于注意力机制的融合" class="headerlink" title="基于注意力机制的融合"></a><h id='2'>基于注意力机制的融合<h></h1><p>注意力机制最早在自然语言处理领域被提出，用于改进基于编码器 - 解码器的神经机器翻译系统。其核心思想是通过对输入数据的不同部分分配差异化权重，使模型聚焦于与当前任务最相关的关键信息，在不显著增加计算成本的前提下提升预测精度。<br>注意力机制衍生出多种变体，例如计算机视觉中的通道注意力、空间注意力，以及自然语言处理中的自注意力、多头注意力等。</p><h2 id="模态内自注意力"><a href="#模态内自注意力" class="headerlink" title="模态内自注意力"></a><h id='2.1'>模态内自注意力<h></h2><p>该机制迫使模型挖掘单一模态内部的依赖关系，注意力计算中的 Query、Key、Value 均来自同一模态。操作方式包括点积注意力、加法门注意力等，确保分析聚焦于单模态数据的内在关联。<br>在视觉问答（VQA）任务中，有方法通过模态内注意力增强各模态子网络的特征学习能力，提升对单模态关键信息的捕捉。<br>仅关注单模态内部关系，可能忽略不同模态间的互补信息，限制模型对跨模态协同效应的利用。</p><h2 id="模态间交叉注意力"><a href="#模态间交叉注意力" class="headerlink" title="模态间交叉注意力"></a><h id='2.2'>模态间交叉注意力<h></h2><p>原理与结构：与模态内自注意力互补，该机制通过跨模态的 Query-Key 匹配计算注意力权重，聚焦不同模态间的交互关系。Query 通常来自目标模态，Key 和 Value 来自辅助模态，生成以辅助模态为条件的目标模态注意力特征。</p><p>协同注意力机制（Co-attention）在融合前通过跨模态交互增强各模态特征，多层堆叠促使模型学习模态间的依赖关系（如多模态假新闻检测）。<br>交叉计算：音频与文本模态通过交叉点积计算注意力，动态更新跨模态特征；或结合通道注意力与特征交叉机制，实现模态间的动态信息交互。<br>不过随着模态数量增加，计算复杂度和结构设计难度上升；模态质量不一致或对齐偏差可能显著影响注意力机制的效果。</p><h2 id="非局部注意力"><a href="#非局部注意力" class="headerlink" title="非局部注意力"></a><h id='2.3'>非局部注意力<h></h2><p>传统注意力机制受限于局部感受野，难以捕捉长距离依赖。非局部注意力通过全局建模输入空间的关系，有效处理跨区域或跨模态的长距离依赖。非局部注意力超越局部约束，提供输入空间的整体视角，提升模型对全局关联信息的利用能力。</p><h1 id="基于图神经网络的融合"><a href="#基于图神经网络的融合" class="headerlink" title="基于图神经网络的融合"></a><h id='3'>基于图神经网络的融合<h></h1><p>传统编码器 - 解码器和注意力机制适用于欧几里得空间数据，但难以处理非欧几里得域的图结构数据（如包含复杂对象关系的数据）。GNN 逐渐成为处理图结构多模态数据的有力工具，广泛应用于视觉问答、图像描述、跨模态检索、推荐系统等任务。其核心优势是直接处理图数据，无需投影到欧几里得空间，并能显式建模模态内与模态间的关系。</p><h1 id="基于生成神经网络的融合"><a href="#基于生成神经网络的融合" class="headerlink" title="基于生成神经网络的融合"></a><h id='4'>基于生成神经网络的融合<h></h1><p>生成式神经网络（GenNN）是深度学习领域的基石，尤其适用于围绕数据生成、重建和建模的任务。这些网络旨在捕捉并复制数据的潜在分布，这使得它们在从图像合成到时间序列预测等众多应用中都具有极高的价值。基于生成式神经网络的网络通常包含一系列架构，包括但不限于生成对抗网络（GANs）、变分自编码器（VAEs）、基于流的模型以及基于扩散的模型。生成式神经网络的主要目标是生成与现实世界数据分布紧密相似的数据，其实现方式要么是直接对这些分布进行建模，要么是学习将更简单的分布转换为更复杂的分布。它们在生成高质量数据方面的多功能性和能力，使其在单模态和多模态任务中都得到了广泛应用，解决了诸如数据插补、增强和融合等挑战。由于其强大的生成能力，生成式模型在真实数据稀缺、有噪声或不完整的情况下发挥了重要作用，为补充和增强现有数据集提供了可靠的机制。</p><p>对于多模态数据融合任务而言，与单模态任务相比，数据收集过程相对更为复杂。缺失数据是多模态数据集常见的问题之一。在此，我们将缺失数据问题定义为由多模态样本导致的问题，即样本中至少有一种模态的数据缺失。在大多数与多模态相关的研究中，研究人员只是简单地假设数据集不存在任何缺失数据，或者通过数据清理来去除所有包含缺失数据的样本。结果是，这些研究中的大多数仅在理论上效果良好，无法适应实际场景。为了解决多模态数据融合中的缺失数据问题，生成式神经网络已成为强大的工具，尤其适用于涉及数据生成、重建和融合的任务。在多模态数据融合的背景下，基于生成式神经网络的网络提供了一个强大的框架，以应对诸如缺失数据和新数据模态合成等挑战。</p><p>总之，基于生成式神经网络的模型可用于解决多模态任务中的缺失数据问题，也可被视为一种正则化器，以利用多模态之间的语义相关性。然而，在挖掘多种模态之间的模态内和模态间关系以提高模型性能方面，基于生成式神经网络的网络架构灵活性相对较低，并且需要大量的训练技巧。在这方面，注意力机制在科学界引起了更多关注。因为注意力机制具有很强的揭示不同模态之间内部和相互关系的能力，所以它已被广泛应用于多模态数据融合中。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a><h id='5'>其他<h></h1><p>我们上面回顾的大多数融合策略都基于联合表示，这意味着输入的多模态数据将被映射到一个共同的潜在空间中。模型将学习输入数据的联合表示。然而，还有另一类方法，称为基于协调表示的框架，该框架在特定约束下学习每个模态的分离但协调的表示。</p><p>协调表示架构分别处理各个模态，但对它们施加一定的相似性约束，以便将它们带入一个协调的空间。每个模态学习到的表示可以通过使用典型相关分析（CCA）约束、余弦距离约束、L2 距离约束或其他约束相互比较。这些相似性约束将作为损失函数中的正则化项。</p><p>这些基于协调表示的融合方法的主要缺点之一是，它们适用于有两到三个输入模态的场景。当模态数量大于三个时，网络架构可能会过于复杂，并且性能无法得到保证。</p>]]></content>
    
    
    <summary type="html">当前的多模态对齐任务分类</summary>
    
    
    
    <category term="deeplearning" scheme="https://wilsssssssson.github.io/categories/deeplearning/"/>
    
    
    <category term="multimodal" scheme="https://wilsssssssson.github.io/tags/multimodal/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript-枚举类型</title>
    <link href="https://wilsssssssson.github.io/2025/03/04/TypeScript-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://wilsssssssson.github.io/2025/03/04/TypeScript-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/</id>
    <published>2025-03-04T08:35:53.000Z</published>
    <updated>2025-05-06T01:56:21.584Z</updated>
    
    <content type="html"><![CDATA[<p>TypeScript (TS) 是一种静态类型的编程语言，它是 JavaScript 的超集，意味着所有有效的 JavaScript 代码也是有效的 TypeScript 代码。TypeScript 添加了可选的类型注解和其他特性到 JavaScript 中，以帮助开发者编写更健壮和易于维护的代码。以下是您提到的一些特性和实现细节：</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举（Enums）是 TypeScript 提供的一种数据类型，它允许开发者定义一组命名的常量。这些常常量可以是数值型、字符串或者其他类型的。</p><h4 id="数值枚举"><a href="#数值枚举" class="headerlink" title="数值枚举"></a>数值枚举</h4><p>最基本的枚举形式是数值枚举，它默认从0开始为成员编号，但您可以手动指定值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span>, <span class="comment">// 默认为0</span></span><br><span class="line">    <span class="title class_">Down</span>, <span class="comment">// 默认为1</span></span><br><span class="line">    <span class="title class_">Left</span>, <span class="comment">// 默认为2</span></span><br><span class="line">    <span class="title class_">Right</span> <span class="comment">// 默认为3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h4><p>除了数值枚举，TypeScript 还支持字符串枚举，这需要显式地为每个成员赋一个字符串值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span> = <span class="string">&quot;UP&quot;</span>,</span><br><span class="line">    <span class="title class_">Down</span> = <span class="string">&quot;DOWN&quot;</span>,</span><br><span class="line">    <span class="title class_">Left</span> = <span class="string">&quot;LEFT&quot;</span>,</span><br><span class="line">    <span class="title class_">Right</span> = <span class="string">&quot;RIGHT&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举的源码与键值转换"><a href="#枚举的源码与键值转换" class="headerlink" title="枚举的源码与键值转换"></a>枚举的源码与键值转换</h3><p>在 TypeScript 编译后，枚举会被转化为对象字面量形式，包含用于双向映射的方法。例如，给定一个简单的数值枚举：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">    A</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译成 JavaScript 后会类似于这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Enum</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Enum</span>) &#123;</span><br><span class="line">    <span class="title class_">Enum</span>[<span class="title class_">Enum</span>[<span class="string">&quot;A&quot;</span>] = <span class="number">0</span>] = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">Enum</span> || (<span class="title class_">Enum</span> = &#123;&#125;));</span><br></pre></td></tr></table></figure><p>这里 <code>Enum[&quot;A&quot;] = 0</code> 和 <code>Enum[0] = &quot;A&quot;</code> 实现了键名和键值之间的相互查找。</p><h3 id="键值相互转换"><a href="#键值相互转换" class="headerlink" title="键值相互转换"></a>键值相互转换</h3><ul><li><strong>从键到值</strong>：直接通过枚举变量访问即可，如 <code>Direction.Up</code> 返回 0。</li><li><strong>从值到键</strong>：由于 TypeScript 在编译时生成了反向映射，所以可以通过索引枚举对象来获取键名，比如 <code>Direction[0]</code> 返回 <code>&quot;Up&quot;</code>。</li></ul><p>这种机制允许你在处理枚举时灵活地在名称和数值之间进行转换。不过需要注意的是，只有当枚举成员的值是唯一的时，这样的反向映射才是有意义的。如果两个成员具有相同的值，则它们将共享同一个键。</p>]]></content>
    
    
    <summary type="html">ts相对js新增类型枚举，可实现k,v之间互相转换</summary>
    
    
    
    <category term="ts" scheme="https://wilsssssssson.github.io/categories/ts/"/>
    
    
    <category term="ts" scheme="https://wilsssssssson.github.io/tags/ts/"/>
    
    <category term="enum" scheme="https://wilsssssssson.github.io/tags/enum/"/>
    
  </entry>
  
  <entry>
    <title>跨域解决方法</title>
    <link href="https://wilsssssssson.github.io/2025/02/23/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://wilsssssssson.github.io/2025/02/23/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</id>
    <published>2025-02-23T07:27:27.000Z</published>
    <updated>2025-02-23T08:15:47.917Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浏览器跨域解决方法"><a href="#浏览器跨域解决方法" class="headerlink" title="浏览器跨域解决方法"></a>浏览器跨域解决方法</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#1">跨域概念解析</a></li><li><a href="#2">JSONP解决方案</a></li><li><a href="#3">document.domain + iframe方案</a></li><li><a href="#4">location.hash + iframe方案</a></li><li><a href="#5">window.name + iframe方案</a></li><li><a href="#6">postMessage API方案</a></li><li><a href="#7">CORS跨域方案</a></li><li><a href="#8">WebSocket协议方案</a></li></ol><h2 id="1">一、跨域概念解析</h2><p>当前浏览器的内容访问要求同源，所谓同源即是<code>url的方案（协议）</code>，<code>主机（域名）</code>，<code>和端定义</code>，<br>只有当方案，主机和端口都匹配时，两个对象具有相同的起源<br>同源策略是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介</p><h2 id="2">二、JSONP解决方案</h2><p>在html标签中很多带src属性的标签都可以跨域请求内容，比如我们熟悉的img图片标签。同理，script标签也可以，<br>通过<code>&lt;script&gt;</code>标签来实现跨域数据请求的方法。其工作原理主要依赖于浏览器对<code>&lt;script&gt;</code>标签的src属性没有同源策略限制这一特性。下面详细解释其实现跨域的步骤：</p><ol><li><p><strong>创建回调函数</strong>：在你的网页中定义一个全局函数，这个函数将被用来处理从其他域返回的数据。</p></li><li><p><strong>构造<code>&lt;script&gt;</code>标签</strong>：动态地创建一个<code>&lt;script&gt;</code>元素，并设置它的src属性为目标服务器的URL。在这个URL中，你需要指定一个参数来告诉服务器你的回调函数名称。</p></li><li><p><strong>服务器响应</strong>：当目标服务器收到请求后，它会构建一段JavaScript代码作为响应。这段代码调用你在第一步中定义的回调函数，并将需要的数据作为参数传递给这个函数。</p></li><li><p><strong>执行脚本</strong>：浏览器接收到服务器的响应后，会执行这段JavaScript代码，从而触发你之前定义的回调函数，完成数据的获取和处理。</p></li></ol><p>例如，假设你想从<code>example.com</code>获取数据，并且已经定义了一个名为<code>handleResponse</code>的回调函数，那么你可以创建一个<code>&lt;script&gt;</code>标签，其src属性为<code>http://example.com/data?callback=handleResponse</code>。服务器应该返回类似<code>handleResponse(&#123;...&#125;)</code>的JavaScript代码，其中<code>&#123;...&#125;</code>是实际的数据。</p><p>需要注意的是，由于JSONP的实现方式，它只能支持GET请求，而且如果服务器不正确地处理回调参数，可能会引发安全问题，如XSS攻击。因此，在使用JSONP时需要格外小心。随着CORS（跨源资源共享）机制的普及，JSONP逐渐被更为安全的CORS替代。</p><h2 id="3">三、document.domain + iframe方案</h2><p>使用 <code>document.domain</code> 和 <code>&lt;iframe&gt;</code> 实现跨域通信是一种传统的方法，主要用于主域名相同但子域名不同的情况下。例如，父页面位于 <code>a.example.com</code>，而子页面位于 <code>b.example.com</code>。通过设置 <code>document.domain</code>，可以让这两个不同子域名的页面认为它们属于同一个源（即相同的主域名），从而允许它们之间进行直接的JavaScript交互。</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol><li><p><strong>设置 <code>document.domain</code></strong>：</p><ul><li>在父页面和子页面中都显式地设置 <code>document.domain</code> 为相同的主域名。比如，如果两个页面分别位于 <code>a.example.com</code> 和 <code>b.example.com</code>，则在每个页面中添加以下代码：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&quot;example.com&quot;</span>;</span><br></pre></td></tr></table></figure>这样做之后，两个页面就会被视为来自同一源。</li></ul></li><li><p><strong>建立 iframe 嵌套</strong>：</p><ul><li>在父页面中嵌入一个指向子页面的 <code>&lt;iframe&gt;</code> 标签：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;myIframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://b.example.com/page.html&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>实现通信</strong>：</p><ul><li>在父页面中，可以通过获取 iframe 的 contentWindow 对象来访问子页面中的 JavaScript 变量或调用其函数。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myIframe&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> iframeWindow = iframe.<span class="property">contentWindow</span>;</span><br><span class="line"><span class="comment">// 调用子页面中的函数</span></span><br><span class="line">iframeWindow.<span class="title function_">someFunction</span>();</span><br></pre></td></tr></table></figure></li><li>同样，在子页面中也可以访问父页面的 JavaScript 变量或调用其函数：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">parent</span>.<span class="title function_">someParentFunction</span>();</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>这种方法仅适用于主域名相同的情况。如果主域名不同，则无法通过此方法解决跨域问题。</li><li>设置 <code>document.domain</code> 可能会影响页面的安全性，因此应谨慎使用，并确保只在受信任的上下文中操作。</li></ul><h2 id="4">四、location.hash + iframe方案</h2><p>使用 <code>location.hash</code> 和 <code>&lt;iframe&gt;</code> 实现跨域通信是一种巧妙的方法，特别适用于需要在不同源的页面之间传递少量数据的情况。这种方法利用了 iframe 的 src 属性和 location 对象的 hash 属性（即 URL 中 “#” 后面的部分），允许父页面和嵌入的 iframe 页面之间进行单向或双向的数据交换。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul><li><strong>父页面</strong>通过修改 iframe 的 src 属性中的 hash 部分来向 iframe 发送消息。</li><li>**子页面（iframe）**可以通过监听自身的 <code>hashchange</code> 事件来接收来自父页面的消息。</li><li>类似地，<strong>子页面</strong>也可以通过修改父页面的 <code>location.hash</code> 来发送消息给父页面，父页面则监听自身的 <code>hashchange</code> 事件来接收这些消息。</li></ul><h3 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h3><h4 id="父页面向-iframe-发送消息"><a href="#父页面向-iframe-发送消息" class="headerlink" title="父页面向 iframe 发送消息"></a>父页面向 iframe 发送消息</h4><ol><li><p>在父页面中创建一个指向目标域名的 iframe：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;myIframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://otherdomain.com/page.html&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通过 JavaScript 修改 iframe 的 src 属性中的 hash 部分来发送消息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myIframe&#x27;</span>);</span><br><span class="line">iframe.<span class="property">src</span> = iframe.<span class="property">src</span>.<span class="title function_">split</span>(<span class="string">&#x27;#&#x27;</span>)[<span class="number">0</span>] + <span class="string">&#x27;#&#x27;</span> + <span class="built_in">encodeURIComponent</span>(<span class="string">&#x27;Hello from parent!&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ol><h4 id="iframe-接收消息并处理"><a href="#iframe-接收消息并处理" class="headerlink" title="iframe 接收消息并处理"></a>iframe 接收消息并处理</h4><ol><li>在 iframe 内部监听 <code>hashchange</code> 事件来捕获来自父页面的消息：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;hashchange&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> message = <span class="built_in">decodeURIComponent</span>(location.<span class="property">hash</span>.<span class="title function_">substr</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received message:&#x27;</span>, message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h4 id="iframe-向父页面发送消息"><a href="#iframe-向父页面发送消息" class="headerlink" title="iframe 向父页面发送消息"></a>iframe 向父页面发送消息</h4><ol><li><p>在 iframe 内部通过修改父页面的 <code>location.hash</code> 来发送消息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    parent.<span class="property">location</span>.<span class="property">hash</span> = <span class="string">&#x27;Message from iframe&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// 跨域时会抛出异常，可以忽略或者做其他处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在父页面中监听 <code>hashchange</code> 事件以接收来自 iframe 的消息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;hashchange&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> message = <span class="built_in">decodeURIComponent</span>(location.<span class="property">hash</span>.<span class="title function_">substr</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received message from iframe:&#x27;</span>, message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>使用 <code>location.hash</code> 进行跨域通信有一定的局限性，比如只能传输简单的字符串信息，并且长度受限于浏览器对 URL 总长度的限制。</li><li>由于涉及到直接操作 URL，频繁的更改可能会导致用户体验问题，如浏览器历史记录条目的增加。</li></ul><h2 id="5">五、window.name + iframe方案</h2><p>使用 <code>window.name</code> 和 <code>&lt;iframe&gt;</code> 实现跨域通信是一种较为巧妙的方法，利用了浏览器的一个特性：<code>window.name</code> 属性在页面的整个生命周期内保持不变，即使页面的 URL 发生变化，只要没有重新加载或导航到其他页面，<code>window.name</code> 的值就不会改变。这使得它成为一种可行的跨域通信手段。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li><p><strong>初始设置</strong>：</p><ul><li>在父页面中创建一个指向目标域名的 iframe。</li><li>目标页面（即 iframe 中加载的页面）设置其 <code>window.name</code> 为需要传递的数据。</li></ul></li><li><p><strong>数据传递</strong>：</p><ul><li>父页面通过将 iframe 的 src 更改为与自身同源的一个空白页（例如，父页面所在域下的一个空 HTML 文件），然后访问 iframe 的 <code>contentWindow.name</code> 来读取之前设置的 <code>window.name</code> 值。</li></ul></li><li><p><strong>清理</strong>：</p><ul><li>由于 <code>window.name</code> 可能会被后续操作覆盖或污染，通常会在读取完数据后立即将其重置为空字符串或其他默认值。</li></ul></li></ol><h3 id="实现步骤-2"><a href="#实现步骤-2" class="headerlink" title="实现步骤"></a>实现步骤</h3><h4 id="目标页面（子页面）"><a href="#目标页面（子页面）" class="headerlink" title="目标页面（子页面）"></a>目标页面（子页面）</h4><ol><li>在目标页面（即要从其获取数据的页面）中设置 <code>window.name</code>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">key</span>: <span class="string">&#x27;value&#x27;</span>&#125;); <span class="comment">// 将需要传递的数据序列化为字符串</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="父页面"><a href="#父页面" class="headerlink" title="父页面"></a>父页面</h4><ol><li><p>创建 iframe 并设置其 src 属性为目标页面的 URL：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;myIframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://otherdomain.com/page.html&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用 JavaScript 修改 iframe 的 src 属性为与父页面同源的一个空白页，并读取 <code>window.name</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myIframe&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 iframe 加载完成时</span></span><br><span class="line">iframe.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 修改 iframe 的 src 到同源的一个空白页</span></span><br><span class="line">    iframe.<span class="property">src</span> = <span class="string">&quot;about:blank&quot;</span>; <span class="comment">// 或者是一个同源的空白HTML文件URL</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问 iframe 的 window.name 获取数据</span></span><br><span class="line">    <span class="keyword">var</span> data = iframe.<span class="property">contentWindow</span>.<span class="property">name</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理接收到的数据</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(data)); <span class="comment">// 解析返回的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理 window.name 防止泄露</span></span><br><span class="line">    iframe.<span class="property">contentWindow</span>.<span class="property">name</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>这种方法适用于一次性的数据传递，因为一旦页面导航或重新加载，<code>window.name</code> 的值可能会被覆盖或丢失。</li><li><code>window.name</code> 的大小有限制（不同浏览器可能有所不同），因此不适合传输大量数据。</li></ul><h2 id="6">六、postMessage API方案</h2><p><code>postMessage</code> 是一种用于实现安全的跨文档消息传递的API，允许来自不同源的窗口或iframe之间进行通信。它不仅适用于父页面和子iframe之间的通信，也适用于任何两个窗口（如通过 <code>window.open</code> 打开的新窗口）之间的通信。这种方法比使用 <code>location.hash</code>、<code>document.domain</code> 或 <code>window.name</code> 更加灵活和安全。</p><h3 id="使用-postMessage-实现跨域通信"><a href="#使用-postMessage-实现跨域通信" class="headerlink" title="使用 postMessage 实现跨域通信"></a>使用 <code>postMessage</code> 实现跨域通信</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>发送消息的一方使用如下格式调用 <code>postMessage</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otherWindow.<span class="title function_">postMessage</span>(message, targetOrigin, [transfer]);</span><br></pre></td></tr></table></figure><ul><li><code>message</code>: 需要传递的数据。可以是任意类型的对象，但如果需要支持旧版浏览器，建议使用基本数据类型或JSON可序列化的对象。</li><li><code>targetOrigin</code>: 指定目标窗口的源（协议+域名+端口），只有当目标窗口的源与此参数匹配时，才会发送消息。使用 <code>&quot;*&quot;</code> 表示不检查源，但这通常不推荐因为存在安全隐患。</li><li><code>[transfer]</code> (可选): 一个数组，包含要转移所有权的对象（例如ArrayBuffer对象）。这些对象在发送后将不再属于发送者。</li></ul><p>接收消息的一方需要监听 <code>message</code> 事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// 检查消息来源是否可信</span></span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">origin</span> !== <span class="string">&#x27;http://expected-origin.com&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理接收到的消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received message:&#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要回复，可以使用 event.source.postMessage()</span></span><br><span class="line">    event.<span class="property">source</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;Response message&#x27;</span>, event.<span class="property">origin</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="父页面向-iframe-发送消息-1"><a href="#父页面向-iframe-发送消息-1" class="headerlink" title="父页面向 iframe 发送消息"></a>父页面向 iframe 发送消息</h4><p><strong>父页面代码：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;myIframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://otherdomain.com/page.html&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myIframe&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 向iframe发送消息</span></span></span><br><span class="line"><span class="language-javascript">    iframe.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        iframe.<span class="property">contentWindow</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;Hello from parent&#x27;</span>, <span class="string">&#x27;http://otherdomain.com&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>iframe代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听来自父页面的消息</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// 确认消息来源</span></span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">origin</span> !== <span class="string">&#x27;http://parentdomain.com&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Message received from parent:&#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回复消息给父页面</span></span><br><span class="line">    event.<span class="property">source</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;Hello back to parent&#x27;</span>, event.<span class="property">origin</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="iframe-向父页面发送消息-1"><a href="#iframe-向父页面发送消息-1" class="headerlink" title="iframe 向父页面发送消息"></a>iframe 向父页面发送消息</h4><p>只需调整上述示例中的角色，即在 iframe 中使用 <code>parent.postMessage()</code> 发送消息，在父页面中监听 <code>message</code> 事件即可。</p><p><strong>iframe代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向父页面发送消息</span></span><br><span class="line">parent.<span class="title function_">postMessage</span>(<span class="string">&#x27;Hello from iframe&#x27;</span>, <span class="string">&#x27;http://parentdomain.com&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>父页面代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听来自iframe的消息</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">origin</span> !== <span class="string">&#x27;http://otherdomain.com&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Message received from iframe:&#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>安全性</strong>: 始终验证 <code>event.origin</code> 来确保消息是从预期的来源接收的。不要信任未经验证的消息内容。</li><li><strong>数据类型</strong>: 虽然可以发送复杂对象，但要注意兼容性问题，特别是在处理旧版浏览器时。</li><li><strong>性能</strong>: 对于频繁的消息传递，考虑消息的大小和频率以避免影响性能。</li></ul><h2 id="7">七、CORS跨域方案</h2><p>跨域资源共享（Cross-Origin Resource Sharing，简称 CORS）是一种基于HTTP的协议，它允许服务器声明哪些源可以访问其资源。CORS通过在HTTP响应中添加特定的头部信息来控制跨域请求的行为，从而增强了Web应用的安全性。</p><h3 id="CORS的工作原理"><a href="#CORS的工作原理" class="headerlink" title="CORS的工作原理"></a>CORS的工作原理</h3><p>CORS机制主要依赖于以下几个HTTP头部：</p><ul><li><strong>Origin</strong>: 这个头部由浏览器自动添加到跨域请求中，表明发起请求的来源（协议+域名+端口）。</li><li><strong>Access-Control-Allow-Origin</strong>: 服务器使用这个头部来指定哪些源可以访问资源。它可以设置为具体的源（如<code>http://example.com</code>），也可以设置为通配符<code>*</code>表示允许所有源访问。</li><li><strong>Access-Control-Allow-Methods</strong>: 指定允许的HTTP方法（如GET, POST, PUT等）。</li><li><strong>Access-Control-Allow-Headers</strong>: 指定除了默认的简单请求头外，还允许哪些自定义请求头。</li><li><strong>Access-Control-Allow-Credentials</strong>: 表示是否允许发送凭据（如Cookies、HTTP认证信息）。默认情况下，CORS请求不会发送这些凭据。</li></ul><h3 id="请求类型"><a href="#请求类型" class="headerlink" title="请求类型"></a>请求类型</h3><p>CORS请求分为两种类型：<strong>简单请求</strong>和<strong>预检请求</strong>。</p><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>满足以下条件的请求被认为是简单请求：</p><ul><li>使用<code>GET</code>, <code>HEAD</code>, 或 <code>POST</code> 方法。</li><li>HTTP 头部仅包含<code>Accept</code>, <code>Accept-Language</code>, <code>Content-Language</code>, <code>Content-Type</code>（但限制为<code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>, 或 <code>text/plain</code>）。</li></ul><p>对于简单请求，浏览器直接发送请求，并检查响应中的<code>Access-Control-Allow-Origin</code>头部以确定是否允许该请求。</p><h4 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h4><p>如果请求不符合简单请求的标准，浏览器会首先发送一个<code>OPTIONS</code>请求（称为预检请求）来询问服务器是否允许实际请求。预检请求会携带如下头部：</p><ul><li><strong>Access-Control-Request-Method</strong>: 实际请求将使用的HTTP方法。</li><li><strong>Access-Control-Request-Headers</strong>: 实际请求将携带的额外HTTP头部。</li></ul><p>服务器需要响应一个200状态码，并且在响应头部中包含必要的CORS头部信息。</p><h3 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>安全性</strong>: 不要随意设置<code>Access-Control-Allow-Origin</code>为<code>*</code>，尤其是在需要发送凭据的情况下。应该根据实际情况精确控制允许访问的源。</li></ul><h2 id="8">八、WebSocket协议方案</h2><p>WebSocket 协议本身并不受限于同源策略（Same-Origin Policy），这意味着 WebSocket 连接可以在不同的源之间建立，而不需要像传统的 HTTP 请求那样处理跨域资源共享（CORS）。然而，在实际应用中，为了确保安全性，服务器通常会验证请求的来源，并决定是否接受连接。</p><h3 id="WebSocket-跨域的基本原理"><a href="#WebSocket-跨域的基本原理" class="headerlink" title="WebSocket 跨域的基本原理"></a>WebSocket 跨域的基本原理</h3><p>在 WebSocket 连接中，浏览器会在握手阶段发送一个标准的 HTTP 请求，该请求包含以下关键头部：</p><ul><li><strong>Origin</strong>: 浏览器自动添加此头部，指示发起 WebSocket 连接的源（协议+域名+端口）。</li><li><strong>Sec-WebSocket-Key</strong>: 用于握手过程中的安全验证。</li><li><strong>Sec-WebSocket-Version</strong>: 指示使用的 WebSocket 协议版本。</li></ul><p>服务器在收到连接请求后，可以通过检查 <code>Origin</code> 头部来决定是否允许该连接。如果服务器认为该来源是可信的，则可以继续握手并建立连接；否则，服务器可以选择拒绝连接。</p><h3 id="服务器端配置-WebSocket-跨域"><a href="#服务器端配置-WebSocket-跨域" class="headerlink" title="服务器端配置 WebSocket 跨域"></a>服务器端配置 WebSocket 跨域</h3><p>以下是js服务器环境下的 WebSocket 跨域配置示例。</p><h4 id="Node-js-使用-ws-库"><a href="#Node-js-使用-ws-库" class="headerlink" title="Node.js 使用 ws 库"></a>Node.js 使用 <code>ws</code> 库</h4><p>在 Node.js 中使用 <code>ws</code> 库时，可以通过中间件或直接在 WebSocket 服务器上设置来处理跨域请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">WebSocket</span> = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>();</span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> <span class="title class_">WebSocket</span>.<span class="title class_">Server</span>(&#123; server &#125;);</span><br><span class="line"></span><br><span class="line">wss.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>, <span class="keyword">function</span> <span class="title function_">connection</span>(<span class="params">ws, req</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> origin = req.<span class="property">headers</span>[<span class="string">&#x27;origin&#x27;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证 Origin 头部</span></span><br><span class="line">    <span class="keyword">if</span> (origin === <span class="string">&#x27;http://allowed-origin.com&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Connection accepted from trusted origin&#x27;</span>);</span><br><span class="line">        ws.<span class="title function_">send</span>(<span class="string">&#x27;Welcome!&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Rejected connection from untrusted origin&#x27;</span>);</span><br><span class="line">        ws.<span class="title function_">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ws.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> <span class="title function_">incoming</span>(<span class="params">message</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;received: %s&#x27;</span>, message);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket server is listening on port 8080&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">在浏览器的同源政策下，浏览器一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容，下面列举一些解决这个的方法</summary>
    
    
    
    <category term="js" scheme="https://wilsssssssson.github.io/categories/js/"/>
    
    
    <category term="js" scheme="https://wilsssssssson.github.io/tags/js/"/>
    
    <category term="跨域" scheme="https://wilsssssssson.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>RN-类的使用</title>
    <link href="https://wilsssssssson.github.io/2025/02/19/RN-%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://wilsssssssson.github.io/2025/02/19/RN-%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2025-02-19T08:47:29.000Z</published>
    <updated>2025-02-19T13:07:22.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-Native-状态管理：函数组件-vs-类组件"><a href="#React-Native-状态管理：函数组件-vs-类组件" class="headerlink" title="React Native 状态管理：函数组件 vs 类组件"></a>React Native 状态管理：函数组件 vs 类组件</h1><p>在React Native中，状态（<code>state</code>）的管理可以通过函数组件使用<code>useState</code>和<code>useEffect</code>钩子来实现，也可以通过类组件的传统方式来处理。以下分别展示了这两种方式的具体实现。</p><h2 id="使用函数组件与Hooks"><a href="#使用函数组件与Hooks" class="headerlink" title="使用函数组件与Hooks"></a>使用函数组件与Hooks</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Index</span> = (<span class="params"></span>) =&gt; &#123;  </span><br><span class="line">  <span class="keyword">const</span> [statusBarColor, setStatusBarColor] = <span class="title function_">useState</span>(<span class="string">&#x27;green&#x27;</span>);  <span class="comment">//react中常用的响应式方法</span></span><br><span class="line">  </span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;  <span class="comment">// 使用useEffect Hook监听statusBarColor的变化，当其变化时执行回调函数</span></span><br><span class="line">    <span class="title class_">StatusBar</span>.<span class="title function_">setBackgroundColor</span>(statusBarColor);  </span><br><span class="line">  &#125;, [statusBarColor]);<span class="comment">// 只有当statusBarColor改变时才会触发此effect</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">toggleStatusBarColor</span> = (<span class="params"></span>) =&gt; &#123;  </span><br><span class="line">    <span class="keyword">const</span> newColor = statusBarColor === <span class="string">&#x27;green&#x27;</span> ? <span class="string">&#x27;red&#x27;</span> : <span class="string">&#x27;green&#x27;</span>;  </span><br><span class="line">    <span class="title function_">setStatusBarColor</span>(newColor);  </span><br><span class="line">  &#125;;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;styles.container&#125;</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Switch</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">trackColor</span>=<span class="string">&#123;&#123;</span> <span class="attr">false:</span> &#x27;<span class="attr">gray</span>&#x27;, <span class="attr">true:</span> &#x27;<span class="attr">green</span>&#x27; &#125;&#125;  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">thumbColor</span>=<span class="string">&quot;blue&quot;</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onValueChange</span>=<span class="string">&#123;toggleStatusBarColor&#125;</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;statusBarColor</span>===<span class="string">&#x27;green&#x27;</span>&#125;  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span>  </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span>  </span><br><span class="line">  );  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用类组件"><a href="#使用类组件" class="headerlink" title="使用类组件"></a>使用类组件</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;  </span><br><span class="line">    <span class="variable language_">super</span>(props);  <span class="comment">// 调用父类构造器</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;  <span class="comment">// 初始化state对b</span></span><br><span class="line">      <span class="attr">statusBarColor</span>: <span class="string">&#x27;green&#x27;</span>,  <span class="comment">// 状态栏颜色初始为绿色</span></span><br><span class="line">      <span class="attr">switchValue</span>: <span class="literal">true</span>  <span class="comment">// 开关初始值为true（开）</span></span><br><span class="line">    &#125;;  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 组件更新后自动调用，检查状态变化并作出相应操作</span></span><br><span class="line">  <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState</span>) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (prevState.<span class="property">statusBarColor</span> !== <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">statusBarColor</span>) &#123;  <span class="comment">// 如果状态栏颜色发生了变化</span></span><br><span class="line">      <span class="title class_">StatusBar</span>.<span class="title function_">setBackgroundColor</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">statusBarColor</span>);  <span class="comment">// 设置状态栏背景颜色</span></span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 切换状态栏颜色的方法</span></span><br><span class="line">  toggleStatusBarColor = <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">    <span class="keyword">const</span> newColor = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">statusBarColor</span> === <span class="string">&#x27;green&#x27;</span> ? <span class="string">&#x27;red&#x27;</span> : <span class="string">&#x27;green&#x27;</span>;  <span class="comment">// 切换颜色</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;  <span class="comment">// 更新状态</span></span><br><span class="line">      <span class="attr">statusBarColor</span>: newColor,  </span><br><span class="line">      <span class="attr">switchValue</span>: !<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">switchValue</span>  <span class="comment">// 同步更新switch的状态</span></span><br><span class="line">    &#125;);  </span><br><span class="line">  &#125;;  </span><br><span class="line">  </span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;  <span class="comment">//react的render在每次组件的state和props改变的时候，调用该函数</span></span><br><span class="line">    <span class="keyword">return</span> (  </span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;styles.container&#125;</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Switch</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">trackColor</span>=<span class="string">&#123;&#123;</span> <span class="attr">false:</span> &#x27;<span class="attr">gray</span>&#x27;, <span class="attr">true:</span> &#x27;<span class="attr">green</span>&#x27; &#125;&#125;  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">thumbColor</span>=<span class="string">&quot;blue&quot;</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onValueChange</span>=<span class="string">&#123;this.toggleStatusBarColor&#125;</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">value</span>=<span class="string">&#123;this.state.switchValue&#125;</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        /&gt;</span>  </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span>  </span><br><span class="line">    );  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">React Native 状态管理：函数组件 vs 类组件</summary>
    
    
    
    <category term="RN" scheme="https://wilsssssssson.github.io/categories/RN/"/>
    
    
    <category term="RN" scheme="https://wilsssssssson.github.io/tags/RN/"/>
    
  </entry>
  
  <entry>
    <title>React-render</title>
    <link href="https://wilsssssssson.github.io/2024/07/12/React-render/"/>
    <id>https://wilsssssssson.github.io/2024/07/12/React-render/</id>
    <published>2024-07-12T01:12:36.000Z</published>
    <updated>2025-02-19T12:52:19.843Z</updated>
    
    <content type="html"><![CDATA[<p><code>render()</code> 方法在 React 组件中扮演着核心角色，它定义了组件的 UI 结构，并且决定了组件最终渲染到页面上的样子。以下是 <code>render()</code> 方法的具体作用和一些关键点：</p><h3 id="核心作用"><a href="#核心作用" class="headerlink" title="核心作用"></a>核心作用</h3><ol><li><p><strong>描述 UI</strong>：<code>render()</code> 方法返回一个 React 元素（可以是一个简单的 DOM 标签、复杂的自定义组件或者它们的组合），这些元素描述了组件的 UI 层次结构。</p></li><li><p><strong>生成虚拟 DOM</strong>：React 使用 JSX 语法（JavaScript 的一种语法扩展）来编写 UI 代码。当组件被渲染时，<code>render()</code> 方法会生成一个虚拟 DOM（Virtual DOM），这是一个轻量级的内存中的 DOM 表示形式。</p></li><li><p><strong>比较与更新</strong>：React 通过对比新旧虚拟 DOM 的差异（这一过程称为“diffing”），然后仅对实际变化的部分进行必要的最小化更新，从而高效地更新真实的 DOM，以保持用户界面的最新状态。</p></li></ol><h3 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h3><ul><li><p><strong>纯函数性</strong>：理论上，<code>render()</code> 应该是无副作用的，意味着它不应该修改组件的状态或执行其他有副作用的操作。它的唯一目的是基于当前的 props 和 state 返回 UI 描述。</p></li><li><p><strong>响应式更新</strong>：每当组件的 props 或 state 发生变化时，React 会自动调用 <code>render()</code> 方法来重新生成 UI，确保显示的内容始终反映最新的数据状态。</p></li><li><p><strong>生命周期的一部分</strong>：对于类组件来说，<code>render()</code> 是生命周期方法之一。它会在组件实例化后首次加载到页面时以及每次组件更新时被调用。而在函数组件中，这个逻辑隐含在函数体内部，因为整个函数本身就是用来定义渲染输出的。</p></li></ul><h3 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h3><p>在你提供的例子中，无论是函数组件还是类组件，<code>render()</code> 都负责定义如何将数据（props 和 state）转化为可视化的 UI 元素。例如，在类组件中，<code>render()</code> 方法返回了一个包含 <code>Switch</code> 组件的 <code>View</code> 组件，根据当前的状态（如 <code>statusBarColor</code> 和 <code>switchValue</code>）决定开关的位置和颜色等属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="keyword">return</span> (  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;styles.container&#125;</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Switch</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">trackColor</span>=<span class="string">&#123;&#123;</span> <span class="attr">false:</span> &#x27;<span class="attr">gray</span>&#x27;, <span class="attr">true:</span> &#x27;<span class="attr">green</span>&#x27; &#125;&#125;  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">thumbColor</span>=<span class="string">&quot;blue&quot;</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onValueChange</span>=<span class="string">&#123;this.toggleStatusBarColor&#125;</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;this.state.switchValue&#125;</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span>  </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span>  </span><br><span class="line">  );  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">render函数的使用及特性</summary>
    
    
    
    <category term="react" scheme="https://wilsssssssson.github.io/categories/react/"/>
    
    
    <category term="react" scheme="https://wilsssssssson.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>RN-连接初始化</title>
    <link href="https://wilsssssssson.github.io/2024/07/01/RN-%E8%BF%9E%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://wilsssssssson.github.io/2024/07/01/RN-%E8%BF%9E%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2024-07-01T05:20:02.000Z</published>
    <updated>2025-02-19T12:53:08.797Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MUMU模拟器与Hermes调试"><a href="#MUMU模拟器与Hermes调试" class="headerlink" title="MUMU模拟器与Hermes调试"></a>MUMU模拟器与Hermes调试</h1><h2 id="连接MUMU模拟器"><a href="#连接MUMU模拟器" class="headerlink" title="连接MUMU模拟器"></a>连接MUMU模拟器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb connect 127.0.0.1:7555</span><br></pre></td></tr></table></figure><h2 id="开发者菜单，用于调试"><a href="#开发者菜单，用于调试" class="headerlink" title="开发者菜单，用于调试"></a>开发者菜单，用于调试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 82</span><br></pre></td></tr></table></figure><h2 id="使用Hermes打开控制台或在Node-js中查看输出"><a href="#使用Hermes打开控制台或在Node-js中查看输出" class="headerlink" title="使用Hermes打开控制台或在Node.js中查看输出"></a>使用Hermes打开控制台或在Node.js中查看输出</h2><h3 id="在-Chrome-浏览器中操作"><a href="#在-Chrome-浏览器中操作" class="headerlink" title="在 Chrome 浏览器中操作"></a>在 Chrome 浏览器中操作</h3><ol><li>导航到 <code>chrome://inspect</code>。</li><li>使用 “Configure…” 按钮添加开发服务器地址（通常是 <code>localhost:8081</code>）。</li><li>现在应该能看到一个带有 “inspect” 链接的 “Hermes React Native” 目标。点击这个链接打开调试器。</li></ol><pre><code></code></pre>]]></content>
    
    
    <summary type="html">react native初始化连接</summary>
    
    
    
    <category term="RN" scheme="https://wilsssssssson.github.io/categories/RN/"/>
    
    
    <category term="RN" scheme="https://wilsssssssson.github.io/tags/RN/"/>
    
  </entry>
  
  <entry>
    <title>Router</title>
    <link href="https://wilsssssssson.github.io/2024/06/23/Router/"/>
    <id>https://wilsssssssson.github.io/2024/06/23/Router/</id>
    <published>2024-06-23T06:30:13.000Z</published>
    <updated>2025-02-19T12:53:42.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="路由链接和视图显示"><a href="#路由链接和视图显示" class="headerlink" title="路由链接和视图显示"></a>路由链接和视图显示</h3><h4 id="路由链接"><a href="#路由链接" class="headerlink" title="路由链接 &lt;RouterLink&gt;"></a>路由链接 <code>&lt;RouterLink&gt;</code></h4><p><code>&lt;RouterLink&gt;</code> 用于导航到不同的路由。以下是几种常见的使用方式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 直接指定路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">active-class</span>=<span class="string">&quot;active&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用名称导航 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name: &#x27;xinwen&#x27;&#125;&quot;</span> <span class="attr">active-class</span>=<span class="string">&quot;active&quot;</span>&gt;</span>新闻<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用路径对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;path: &#x27;/about&#x27;&#125;&quot;</span> <span class="attr">active-class</span>=<span class="string">&quot;active&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="显示路由加载区域"><a href="#显示路由加载区域" class="headerlink" title="显示路由加载区域 &lt;RouterView&gt;"></a>显示路由加载区域 <code>&lt;RouterView&gt;</code></h4><p><code>&lt;RouterView&gt;</code> 是路由匹配到的组件将要渲染的地方。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RouterView</span>&gt;</span><span class="tag">&lt;/<span class="name">RouterView</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="路由配置文件-index-ts"><a href="#路由配置文件-index-ts" class="headerlink" title="路由配置文件 index.ts"></a>路由配置文件 <code>index.ts</code></h3><p>在 <code>index.ts</code> 文件中配置路由规则：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;./views/Home.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">News</span> <span class="keyword">from</span> <span class="string">&#x27;./views/News.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Detail</span> <span class="keyword">from</span> <span class="string">&#x27;./views/Detail.vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(), <span class="comment">// 路由器的工作模式</span></span><br><span class="line">  <span class="attr">routes</span>: [ <span class="comment">// 路由规则</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;zhuye&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Home</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;xinwen&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/news&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">News</span>,</span><br><span class="line">      <span class="attr">children</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">path</span>: <span class="string">&#x27;detail&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>: <span class="title class_">Detail</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure><h2 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h2><h3 id="Query-参数传递"><a href="#Query-参数传递" class="headerlink" title="Query 参数传递"></a>Query 参数传递</h3><p>通过 <code>query</code> 参数进行传参：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">    name: &#x27;xiang&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">    query: &#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">      id: news.id,</span></span></span><br><span class="line"><span class="string"><span class="tag">      title: news.title,</span></span></span><br><span class="line"><span class="string"><span class="tag">      content: news.content</span></span></span><br><span class="line"><span class="string"><span class="tag">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="tag">  &#125;&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  新闻详情</span><br><span class="line"><span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="接收参数"><a href="#接收参数" class="headerlink" title="接收参数"></a>接收参数</h4><p><strong>方法1：使用 <code>props</code></strong></p><p>在路由配置中设置 <code>props</code> 函数来接收参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/xiang&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="title class_">Xiang</span>,</span><br><span class="line">  <span class="title function_">props</span>(<span class="params">route</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> route.<span class="property">query</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件内使用 <code>defineProps</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">defineProps</span>([<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;content&#x27;</span>]);</span><br></pre></td></tr></table></figure><p><strong>方法2：直接使用 <code>$route</code></strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>编号：&#123;&#123; $route.query.id &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>标题：&#123;&#123; $route.query.title &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>内容：&#123;&#123; $route.query.content &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者使用组合式API：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRoute &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;@vueuse/core&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> route = <span class="title function_">useRoute</span>();</span><br><span class="line">    <span class="keyword">const</span> &#123; query &#125; = <span class="title function_">toRefs</span>(route);</span><br><span class="line">    <span class="keyword">return</span> &#123; query &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h2><p>可以使用 <code>router.push()</code>、<code>router.replace()</code> 等方法进行编程式导航：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">replace</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xiang&#x27;</span>,</span><br><span class="line">  <span class="attr">query</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: news.<span class="property">id</span>,</span><br><span class="line">    <span class="attr">title</span>: news.<span class="property">title</span>,</span><br><span class="line">    <span class="attr">content</span>: news.<span class="property">content</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h2><p>在路由配置中添加重定向规则：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">  <span class="attr">redirect</span>: <span class="string">&#x27;/home&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">vue3中路由的概念以及一些使用方法</summary>
    
    
    
    <category term="vue3" scheme="https://wilsssssssson.github.io/categories/vue3/"/>
    
    
    <category term="vue3" scheme="https://wilsssssssson.github.io/tags/vue3/"/>
    
    <category term="Router" scheme="https://wilsssssssson.github.io/tags/Router/"/>
    
  </entry>
  
  <entry>
    <title>slot</title>
    <link href="https://wilsssssssson.github.io/2024/06/13/slot/"/>
    <id>https://wilsssssssson.github.io/2024/06/13/slot/</id>
    <published>2024-06-13T06:51:02.000Z</published>
    <updated>2025-02-19T12:54:04.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-插槽（Slots）详解"><a href="#Vue-插槽（Slots）详解" class="headerlink" title="Vue 插槽（Slots）详解"></a>Vue 插槽（Slots）详解</h1><h2 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span>&gt;</span>默认内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Category</span> <span class="attr">title</span>=<span class="string">&quot;今日影视推荐&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">video</span> <span class="attr">:src</span>=<span class="string">&quot;videoUrl&quot;</span> <span class="attr">controls</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;category&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;s1&quot;</span>&gt;</span>默认内容1<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;s2&quot;</span>&gt;</span>默认内容2<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Category</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:s2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;imgUrl&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:s1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>今日美食城市<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="作用域插槽-父亲决定孩子的样式，但是数据还是儿子自己的"><a href="#作用域插槽-父亲决定孩子的样式，但是数据还是儿子自己的" class="headerlink" title="作用域插槽 (父亲决定孩子的样式，但是数据还是儿子自己的)"></a>作用域插槽 (父亲决定孩子的样式，但是数据还是儿子自己的)</h2><h3 id="子组件"><a href="#子组件" class="headerlink" title="子组件"></a>子组件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">:youxi</span>=<span class="string">&quot;games&quot;</span> <span class="attr">x</span>=<span class="string">&quot;哈哈&quot;</span> <span class="attr">y</span>=<span class="string">&quot;你好&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="父组件"><a href="#父组件" class="headerlink" title="父组件"></a>父组件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Game</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot</span>=<span class="string">&quot;params&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- params 可以自定义 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;y in params.youxi&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;y.id&quot;</span>&gt;</span></span><br><span class="line">                &#123;&#123; y.name &#125;&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Game</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="综合使用"><a href="#综合使用" class="headerlink" title="综合使用"></a>综合使用</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:name</span>=<span class="string">&quot;params&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 其中 name 是具名插槽的名字，params 是子组件传过来的数据 --&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Vue 插槽（Slots）详解，介绍一些不同的插槽以及基本代码</summary>
    
    
    
    <category term="vue3" scheme="https://wilsssssssson.github.io/categories/vue3/"/>
    
    
    <category term="vue3" scheme="https://wilsssssssson.github.io/tags/vue3/"/>
    
    <category term="slot" scheme="https://wilsssssssson.github.io/tags/slot/"/>
    
  </entry>
  
  <entry>
    <title>lazyLoading</title>
    <link href="https://wilsssssssson.github.io/2024/06/13/lazyLoading/"/>
    <id>https://wilsssssssson.github.io/2024/06/13/lazyLoading/</id>
    <published>2024-06-13T05:30:51.000Z</published>
    <updated>2025-02-19T12:52:45.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Vue生命周期钩子实现懒加载"><a href="#使用Vue生命周期钩子实现懒加载" class="headerlink" title="使用Vue生命周期钩子实现懒加载"></a>使用Vue生命周期钩子实现懒加载</h1><p>在Vue应用中，可以通过监听<code>scroll</code>事件和利用组件的生命周期钩子来实现数据的懒加载。下面是一个简单的示例，展示了如何实现这一功能。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code class="language-javascript">export default &#123;  data() &#123;    return &#123;      dataList: [], // 初始数据列表      isLoading: false, // 加载状态      page: 1, // 当前页码    &#125;;  &#125;,  mounted() &#123;    this.loadMoreData();    window.addEventListener(&#39;scroll&#39;, this.handleScroll);  &#125;,  methods: &#123;    loadMoreData() &#123;      this.isLoading = true;      // 模拟数据加载      setTimeout(() =&gt; &#123;        // 假设每次加载5条数据        const newData = Array.from(&#123; length: 5 &#125;, (_, index) =&gt; (&#123;          id: this.dataList.length + index + 1,          content: `数据 $&#123;this.page + index&#125;`,        &#125;));        this.dataList.push(...newData);        this.isLoading = false;        this.page++;      &#125;, 1000); // 利用setTimeout模拟加载数据，实际应替换为HTTP请求    &#125;,    handleScroll() &#123;      // 判断是否滚动到底部      const scrollElement = this.$refs.scrollContainer;      if (        scrollElement.scrollHeight - scrollElement.scrollTop ===        scrollElement.clientHeight      ) &#123;        if (!this.isLoading) &#123;          this.loadMoreData();        &#125;      &#125;    &#125;,  &#125;,  beforeDestroy() &#123;    window.removeEventListener(&#39;scroll&#39;, this.handleScroll);  &#125;,&#125;;</code></pre>]]></content>
    
    
    <summary type="html">在Vue应用中，可以通过监听`scroll`事件和利用组件的生命周期钩子来实现数据的懒加载。下面是一个简单的示例，展示了如何实现这一功能</summary>
    
    
    
    <category term="vue3" scheme="https://wilsssssssson.github.io/categories/vue3/"/>
    
    <category term="Hook" scheme="https://wilsssssssson.github.io/categories/vue3/Hook/"/>
    
    
    <category term="vue3" scheme="https://wilsssssssson.github.io/tags/vue3/"/>
    
    <category term="Hook" scheme="https://wilsssssssson.github.io/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title>watch监视</title>
    <link href="https://wilsssssssson.github.io/2024/05/22/watch%E7%9B%91%E8%A7%86/"/>
    <id>https://wilsssssssson.github.io/2024/05/22/watch%E7%9B%91%E8%A7%86/</id>
    <published>2024-05-22T11:30:39.000Z</published>
    <updated>2025-02-19T12:54:22.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue-js-Watch-监视器使用详解"><a href="#Vue-js-Watch-监视器使用详解" class="headerlink" title="Vue.js Watch 监视器使用详解"></a>Vue.js Watch 监视器使用详解</h2><h3 id="监视对象类型"><a href="#监视对象类型" class="headerlink" title="监视对象类型"></a>监视对象类型</h3><ul><li><strong>函数</strong>：返回一个值。</li><li><strong>Ref</strong>：监视由 <code>ref</code> 定义的对象类型数据时，实际上是在监视对象的地址值。若要监视对象内部属性的变化，需手动开启深度监视。</li><li><strong>响应式对象</strong>：当监视响应式对象中的某个基本类型的属性时，需要以函数的形式来定义。</li></ul><p>此外，还可以监视由上述类型组成的数组。</p><p><a href="https://cn.vuejs.org/api/reactivity-core.html#watch">Vue.js官方文档</a></p><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ul><li><code>immediate</code>: 在侦听器创建时立即触发回调。第一次调用时旧值是 <code>undefined</code>。</li><li><code>deep</code>: 如果源是对象，强制深度遍历以便在深层级变更时触发回调。</li><li><code>flush</code>: 调整回调函数的刷新时机，可参考回调的刷新时机及 <code>watchEffect()</code>。</li><li><code>onTrack / onTrigger</code>: 用于调试侦听器的依赖关系。</li><li><code>once</code>: 回调函数只会运行一次，侦听器将在回调函数首次运行后自动停止。</li></ul><blockquote><p>注意：<code>watchEffect</code> 可实现监视页面的所有属性，并且可以实现页面懒加载。</p></blockquote><h3 id="订阅-subscribe-实例"><a href="#订阅-subscribe-实例" class="headerlink" title="订阅 (subscribe) 实例"></a>订阅 (<code>subscribe</code>) 实例</h3><pre><code class="language-javascript">talkStore.$subscribe((mutation, state) =&gt; &#123;    console.log(&#39;talkStore里面保存的数据发生了变化&#39;, mutation, state);    localStorage.setItem(&#39;talkList&#39;, JSON.stringify(state.talkList));&#125;);</code></pre>]]></content>
    
    
    <summary type="html">watch，watchweffect,subscribe的使用方法</summary>
    
    
    
    <category term="vue3" scheme="https://wilsssssssson.github.io/categories/vue3/"/>
    
    <category term="watch" scheme="https://wilsssssssson.github.io/categories/vue3/watch/"/>
    
    
    <category term="vue3" scheme="https://wilsssssssson.github.io/tags/vue3/"/>
    
    <category term="watch" scheme="https://wilsssssssson.github.io/tags/watch/"/>
    
  </entry>
  
  <entry>
    <title>asynchronous</title>
    <link href="https://wilsssssssson.github.io/2024/05/17/asynchronous/"/>
    <id>https://wilsssssssson.github.io/2024/05/17/asynchronous/</id>
    <published>2024-05-17T07:44:42.000Z</published>
    <updated>2025-02-19T12:54:35.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浏览器多线程与-JavaScript-异步操作"><a href="#浏览器多线程与-JavaScript-异步操作" class="headerlink" title="浏览器多线程与 JavaScript 异步操作"></a>浏览器多线程与 JavaScript 异步操作</h1><h2 id="浏览器多线程"><a href="#浏览器多线程" class="headerlink" title="浏览器多线程"></a>浏览器多线程</h2><p>浏览器通过多个线程来处理不同的任务，以下是主要的线程及其功能：</p><h3 id="主要线程"><a href="#主要线程" class="headerlink" title="主要线程"></a>主要线程</h3><ul><li><strong>GUI 渲染线程</strong>：负责渲染和解析页面内容。</li><li><strong>JS 引擎线程</strong>：负责解析和执行 JavaScript 代码。浏览器只为每个标签页分配一个 JS 引擎线程，因此它是单线程的。</li><li><strong>定时器监听线程</strong>：负责管理 <code>setTimeout</code> 和 <code>setInterval</code> 等定时器操作。</li><li><strong>事件监听线程</strong>：负责监听用户交互事件（如点击、键盘输入等）并触发相应的回调函数。</li><li><strong>HTTP 网络请求线程</strong>：用于处理网络请求。在同一源下，浏览器通常最多分配 5-7 个网络请求线程。</li></ul><h3 id="其他线程"><a href="#其他线程" class="headerlink" title="其他线程"></a>其他线程</h3><p>浏览器还可能有其他线程，例如：</p><ul><li>WebSocket 线程</li><li>文件读取线程</li></ul><h2 id="JavaScript-异步操作"><a href="#JavaScript-异步操作" class="headerlink" title="JavaScript 异步操作"></a>JavaScript 异步操作</h2><p>JavaScript 是单线程语言，但它可以通过异步编程模型实现非阻塞操作。这主要依赖于事件循环机制（Event Loop）以及微任务（Microtasks）和宏任务（Macrotasks）的概念。</p><h3 id="异步微任务"><a href="#异步微任务" class="headerlink" title="异步微任务"></a>异步微任务</h3><p>微任务在当前任务完成后立即执行，优先级较高。常见的微任务包括：</p><ul><li><code>requestAnimationFrame</code></li><li><code>Promise</code></li><li><code>async/await</code></li><li><code>queueMicrotask</code></li><li><code>MutationObserver</code></li><li><code>IntersectionObserver</code></li></ul><h3 id="异步宏任务"><a href="#异步宏任务" class="headerlink" title="异步宏任务"></a>异步宏任务</h3><p>宏任务在每次事件循环的末尾执行，优先级较低。常见的宏任务包括：</p><ul><li><code>setTimeout</code></li><li><code>setInterval</code></li><li>事件绑定（如点击事件）</li></ul><h3 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h3><p>JavaScript 中的异步操作是通过浏览器的多线程机制和基于事件循环（Event Loop）的机制来实现的。以下是事件循环的基本流程：</p><ol><li><strong>执行全局脚本</strong>：首先执行全局脚本中的同步代码。</li><li><strong>执行微任务队列</strong>：当全局脚本执行完毕后，会依次执行所有微任务队列中的任务。</li><li><strong>执行宏任务队列</strong>：微任务队列执行完毕后，会从宏任务队列中取出一个任务执行。</li><li><strong>重复步骤 2 和 3</strong>：不断重复执行微任务和宏任务队列中的任务，直到所有任务都完成。</li></ol><img src="/2024/05/17/asynchronous/image.png" class="" title="This is an example image">]]></content>
    
    
    <summary type="html">js利用浏览器的多线程模拟异步操作</summary>
    
    
    
    <category term="js" scheme="https://wilsssssssson.github.io/categories/js/"/>
    
    
    <category term="js" scheme="https://wilsssssssson.github.io/tags/js/"/>
    
    <category term="multi-process" scheme="https://wilsssssssson.github.io/tags/multi-process/"/>
    
  </entry>
  
  <entry>
    <title>Component Communication</title>
    <link href="https://wilsssssssson.github.io/2024/05/14/Component-Communication/"/>
    <id>https://wilsssssssson.github.io/2024/05/14/Component-Communication/</id>
    <published>2024-05-14T03:24:11.000Z</published>
    <updated>2025-02-19T12:51:17.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-js-组件之间通信概念详解"><a href="#Vue-js-组件之间通信概念详解" class="headerlink" title="Vue.js 组件之间通信概念详解"></a>Vue.js 组件之间通信概念详解</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li>Props</li><li>自定义事件</li><li>mitt（略）</li><li>v-model</li><li>$attrs</li><li>$refs、$parent</li><li>provide、inject</li><li>Pinia</li><li>Slot</li></ol><h2 id="1-Props-父传子数据，子传父"><a href="#1-Props-父传子数据，子传父" class="headerlink" title="1. Props (父传子数据，子传父)"></a>1. Props (父传子数据，子传父)</h2><p>Props用于父组件向子组件传递数据。子组件通过父亲的方法实现数据回传。</p><ul><li><strong>Father Component</strong>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">:car</span>=<span class="string">&quot;car&quot;</span> <span class="attr">:sendToy</span>=<span class="string">&quot;getToy&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>Children Component</strong>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">defineProps</span>([<span class="string">&#x27;car&#x27;</span>,<span class="string">&#x27;sendToy&#x27;</span>])</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-自定义事件-子传父"><a href="#2-自定义事件-子传父" class="headerlink" title="2. 自定义事件 (子传父)"></a>2. 自定义事件 (子传父)</h2><p>通过自定义事件可以将方法从父组件传递给子组件以实现子到父的数据传输。</p><ul><li><strong>Father Component</strong>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Child</span> @<span class="attr">send-toy</span>=<span class="string">&quot;saveToy&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>Children Component</strong>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> emit = <span class="title function_">defineEmits</span>([<span class="string">&#x27;send-toy&#x27;</span>]);</span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;emit(&#x27;send-toy&#x27;, toy)&quot;</span>&gt;</span>Send Toy<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><h2 id="4-v-model"><a href="#4-v-model" class="headerlink" title="4. v-model"></a>4. v-model</h2><p>v-model用于实现双向数据绑定，可以在HTML标签或组件标签上使用。</p><ul><li><strong>示例</strong>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">AtguiguInput</span> <span class="attr">v-model:ming</span>=<span class="string">&quot;username&quot;</span> <span class="attr">v-model:mima</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="7-Provide-Inject"><a href="#7-Provide-Inject" class="headerlink" title="7. Provide &amp; Inject"></a>7. Provide &amp; Inject</h2><p>Provide允许祖先组件向其所有后代组件提供数据，而Inject则让后代组件接收这些数据。</p><ul><li><strong>Ancestor Component</strong>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">provide</span>(<span class="string">&#x27;moneyContext&#x27;</span>, &#123;money, updateMoney&#125;)</span><br></pre></td></tr></table></figure></li><li><strong>Descendant Component</strong>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;money, updateMoney&#125; = <span class="title function_">inject</span>(<span class="string">&#x27;moneyContext&#x27;</span>, &#123;<span class="attr">money</span>:<span class="number">0</span>, <span class="attr">updateMoney</span>:<span class="function">(<span class="params">param:number</span>)=&gt;</span>&#123;&#125;&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>更多关于Pinia和其他Vue.js核心概念的详细解释将在后续部分中介绍。</p>]]></content>
    
    
    <summary type="html">Vue.js 组件之间通信概念详解</summary>
    
    
    
    <category term="vue3" scheme="https://wilsssssssson.github.io/categories/vue3/"/>
    
    
    <category term="Component Communication" scheme="https://wilsssssssson.github.io/tags/Component-Communication/"/>
    
    <category term="vue3" scheme="https://wilsssssssson.github.io/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>lifeCycle</title>
    <link href="https://wilsssssssson.github.io/2024/05/12/lifeCycle/"/>
    <id>https://wilsssssssson.github.io/2024/05/12/lifeCycle/</id>
    <published>2024-05-12T05:22:01.000Z</published>
    <updated>2025-02-19T12:52:03.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-生命周期钩子函数使用笔记"><a href="#Vue-生命周期钩子函数使用笔记" class="headerlink" title="Vue 生命周期钩子函数使用笔记"></a>Vue 生命周期钩子函数使用笔记</h1><p>当我们将这些生命周期钩子函数写在自定义Hooks里面时，意味着只要组件引用了这个Hooks，相应的生命周期事件就会自动绑定到该组件上。</p><h2 id="生命周期钩子示例代码"><a href="#生命周期钩子示例代码" class="headerlink" title="生命周期钩子示例代码"></a>生命周期钩子示例代码</h2><h3 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h3><ul><li><p><strong>挂载前</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onBeforeMount</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// console.log(&#x27;挂载前&#x27;)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>挂载完毕</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;子---挂载完毕&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h3><ul><li><p><strong>更新前</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onBeforeUpdate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// console.log(&#x27;更新前&#x27;)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>更新完毕</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onUpdated</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// console.log(&#x27;更新完毕&#x27;)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h3><ul><li><p><strong>卸载前</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onBeforeUnmount</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// console.log(&#x27;卸载前&#x27;)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>卸载完毕</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onUnmounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// console.log(&#x27;卸载完毕&#x27;)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><img src="/2024/05/12/lifeCycle/image.png" class="" title="This is an example image">]]></content>
    
    
    <summary type="html">生命周期钩子函数使用笔记,主要介绍一些生命周期，以及之间的时间顺序</summary>
    
    
    
    <category term="vue3" scheme="https://wilsssssssson.github.io/categories/vue3/"/>
    
    <category term="Hook" scheme="https://wilsssssssson.github.io/categories/vue3/Hook/"/>
    
    
    <category term="vue3" scheme="https://wilsssssssson.github.io/tags/vue3/"/>
    
    <category term="Hook" scheme="https://wilsssssssson.github.io/tags/Hook/"/>
    
    <category term="lifeCycle" scheme="https://wilsssssssson.github.io/tags/lifeCycle/"/>
    
  </entry>
  
  <entry>
    <title>javascript-防抖节流</title>
    <link href="https://wilsssssssson.github.io/2024/05/09/javascript-%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/"/>
    <id>https://wilsssssssson.github.io/2024/05/09/javascript-%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</id>
    <published>2024-05-09T03:22:16.000Z</published>
    <updated>2025-02-19T12:50:28.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript中的防抖与节流技术"><a href="#JavaScript中的防抖与节流技术" class="headerlink" title="JavaScript中的防抖与节流技术"></a>JavaScript中的防抖与节流技术</h1><p>在处理频繁触发的事件（如窗口调整大小、滚动、输入框输入等）时，为了提高性能和用户体验，我们通常会使用防抖（Debounce）或节流（Throttle）技术。下面分别介绍这两种技术的实现方法。</p><h2 id="防抖-Debounce"><a href="#防抖-Debounce" class="headerlink" title="防抖 (Debounce)"></a>防抖 (Debounce)</h2><p>防抖的基本思想是：当事件被触发后，延迟指定的时间间隔再执行函数，如果在这个时间间隔内该事件又被触发，则重新计时。</p><h3 id="实现代码示例"><a href="#实现代码示例" class="headerlink" title="实现代码示例"></a>实现代码示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取元素</span></span><br><span class="line"><span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;fangdou&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">numberadd</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">innerHTML</span> = <span class="built_in">parseInt</span>(<span class="variable language_">this</span>.<span class="property">innerHTML</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给元素绑定mousemove事件，并应用防抖</span></span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="title function_">debounce</span>(numberadd, <span class="number">500</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, time</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">            func.<span class="title function_">apply</span>(<span class="variable language_">this</span>);</span><br><span class="line">        &#125;, time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>: 使用箭头函数可以让<code>this</code>上下文自动正确地绑定，因此不需要手动用<code>apply</code>方法来绑定<code>this</code>。</p><h2 id="节流-Throttle"><a href="#节流-Throttle" class="headerlink" title="节流 (Throttle)"></a>节流 (Throttle)</h2><p>节流的核心概念是：保证一个函数在一定时间内只执行一次，即使这个时间段内该函数被多次触发。</p><h3 id="实现代码示例-1"><a href="#实现代码示例-1" class="headerlink" title="实现代码示例"></a>实现代码示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, time</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="keyword">return</span>;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(<span class="variable language_">this</span>);</span><br><span class="line">            timer = <span class="literal">null</span>; <span class="comment">// 清空定时器</span></span><br><span class="line">        &#125;, time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">在网页端容易出现用户频繁点击导致网页抖动或请求平凡发送，这个文章用settime设置计时器实现防抖即节流</summary>
    
    
    
    <category term="js" scheme="https://wilsssssssson.github.io/categories/js/"/>
    
    
    <category term="js" scheme="https://wilsssssssson.github.io/tags/js/"/>
    
    <category term="防抖" scheme="https://wilsssssssson.github.io/tags/%E9%98%B2%E6%8A%96/"/>
    
    <category term="节流" scheme="https://wilsssssssson.github.io/tags/%E8%8A%82%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>javascript-promise</title>
    <link href="https://wilsssssssson.github.io/2024/05/05/javascript-promise/"/>
    <id>https://wilsssssssson.github.io/2024/05/05/javascript-promise/</id>
    <published>2024-05-05T10:00:38.000Z</published>
    <updated>2025-02-19T12:49:54.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-Promise-状态与方法详解"><a href="#JavaScript-Promise-状态与方法详解" class="headerlink" title="JavaScript Promise 状态与方法详解"></a>JavaScript Promise 状态与方法详解</h1><h2 id="Promise-的三种状态"><a href="#Promise-的三种状态" class="headerlink" title="Promise 的三种状态"></a>Promise 的三种状态</h2><p>Promise 对象有以下三种状态：</p><ul><li><strong>待定（pending）</strong>：初始状态，既没有被兑现，也没有被拒绝。</li><li><strong>已兑现（fulfilled）</strong>：意味着操作成功完成。</li><li><strong>已拒绝（rejected）</strong>：意味着操作失败。</li></ul><img src="/2024/05/05/javascript-promise/promises.png" class="" title="promise流程"><h2 id="then-方法"><a href="#then-方法" class="headerlink" title=".then() 方法"></a><code>.then()</code> 方法</h2><p><code>.then()</code> 方法用于处理 Promise 的结果。它最多接受两个参数：</p><ol><li>第一个参数是 Promise 兑现时的回调函数。</li><li>第二个参数是 Promise 拒绝时的回调函数。</li></ol><p>每个 <code>.then()</code> 返回一个新的 Promise 对象，可以用于链式调用。</p><h2 id="Promise-并发控制"><a href="#Promise-并发控制" class="headerlink" title="Promise 并发控制"></a>Promise 并发控制</h2><p>Promise 类提供了四个静态方法来促进异步任务的并发：</p><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a><code>Promise.all()</code></h3><p>在所有传入的 Promise 都被兑现时兑现；在任意一个 Promise 被拒绝时拒绝。</p><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled()"></a><code>Promise.allSettled()</code></h3><p>在所有的 Promise 都被敲定时兑现，无论它们是被兑现还是被拒绝。</p><h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a><code>Promise.any()</code></h3><p>在任意一个 Promise 被兑现时兑现；仅在所有的 Promise 都被拒绝时才会拒绝。</p><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a><code>Promise.race()</code></h3><p>在任意一个 Promise 被敲定时敲定。换句话说，在任意一个 Promise 被兑现或被拒绝时立即返回。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>下面是一个完整的示例，展示了如何使用 Promise 处理异步操作及其错误处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了尝试错误处理，使用“阈值”值会随机地引发错误。</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">THRESHOLD_A</span> = <span class="number">8</span>; <span class="comment">// 可以使用 0 使错误必现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tetheredGetNumber</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行了tetheredGetNumber&#x27;</span>, resolve, reject);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> randomInt = <span class="title class_">Date</span>.<span class="title function_">now</span>(); <span class="comment">// 当前时间戳</span></span><br><span class="line">        <span class="keyword">const</span> value = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="variable constant_">THRESHOLD_A</span>) &#123; <span class="comment">// 小于8的时间</span></span><br><span class="line">            <span class="title function_">resolve</span>(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">`太大了：<span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">determineParity</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行了determineParity&#x27;</span>, value);</span><br><span class="line">    <span class="keyword">const</span> isOdd = value % <span class="number">2</span> === <span class="number">1</span>; <span class="comment">// 判断是否为奇数</span></span><br><span class="line">    <span class="keyword">return</span> &#123; value, isOdd &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">troubleWithGetNumber</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行了troubleWithGetNumber&#x27;</span>, reason);</span><br><span class="line">    <span class="keyword">const</span> err = <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;获取数据时遇到问题&quot;</span>, &#123; <span class="attr">cause</span>: reason &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">promiseGetWord</span>(<span class="params">parityInfo</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行了promiseGetWord&#x27;</span>, parityInfo);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; value, isOdd &#125; = parityInfo;</span><br><span class="line">        <span class="keyword">if</span> (value &gt;= <span class="variable constant_">THRESHOLD_A</span> - <span class="number">1</span>) &#123; <span class="comment">// 7</span></span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">`还是太大了：<span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parityInfo.<span class="property">wordEvenOdd</span> = isOdd ? <span class="string">&quot;奇数&quot;</span> : <span class="string">&quot;偶数&quot;</span>;</span><br><span class="line">            <span class="title function_">resolve</span>(parityInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(tetheredGetNumber)</span><br><span class="line">    .<span class="title function_">then</span>(determineParity, troubleWithGetNumber) <span class="comment">// then 接受两个参数，（成功之后执行，失败之后执行）</span></span><br><span class="line">    .<span class="title function_">then</span>(promiseGetWord)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">info</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`得到了：<span class="subst">$&#123;info.value&#125;</span>, <span class="subst">$&#123;info.wordEvenOdd&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (reason.<span class="property">cause</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;已经在前面处理过错误了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`运行 promiseGetWord() 时遇到问题：<span class="subst">$&#123;reason&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;所有回调都完成了&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ol><li><strong><code>tetheredGetNumber</code></strong>：模拟异步操作，使用 <code>setTimeout</code> 模拟延迟，并根据阈值决定是兑现还是拒绝 Promise。</li><li><strong><code>determineParity</code></strong>：检查数字是奇数还是偶数，并返回包含该信息的对象。</li><li><strong><code>troubleWithGetNumber</code></strong>：处理 Promise 被拒绝的情况，抛出一个新的错误。</li><li><strong><code>promiseGetWord</code></strong>：根据阈值决定是否继续兑现 Promise 或拒绝它，并添加额外的信息到对象中。</li><li><strong>链式调用</strong>：通过 <code>.then()</code> 方法处理成功和失败的结果，并最终使用 <code>.catch()</code> 和 <code>.finally()</code> 进行错误处理和清理工作。</li></ol>]]></content>
    
    
    <summary type="html">详解js的promise机制</summary>
    
    
    
    <category term="js" scheme="https://wilsssssssson.github.io/categories/js/"/>
    
    
    <category term="js" scheme="https://wilsssssssson.github.io/tags/js/"/>
    
    <category term="promise" scheme="https://wilsssssssson.github.io/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>javascript-json</title>
    <link href="https://wilsssssssson.github.io/2024/04/01/javascript-json/"/>
    <id>https://wilsssssssson.github.io/2024/04/01/javascript-json/</id>
    <published>2024-04-01T14:52:19.000Z</published>
    <updated>2025-02-19T12:49:32.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-中的-JSON-处理"><a href="#JavaScript-中的-JSON-处理" class="headerlink" title="JavaScript 中的 JSON 处理"></a>JavaScript 中的 JSON 处理</h1><p>JavaScript 内置了对 JSON 的解析支持，允许轻松地在 JSON 和 JavaScript 对象之间进行转换。</p><h2 id="JSON-数据类型"><a href="#JSON-数据类型" class="headerlink" title="JSON 数据类型"></a>JSON 数据类型</h2><p>JSON 支持的数据类型包括：</p><ul><li><strong>number</strong>：与 JavaScript 的 <code>number</code> 完全一致。</li><li><strong>boolean</strong>：即 JavaScript 的 <code>true</code> 或 <code>false</code>。</li><li><strong>string</strong>：即 JavaScript 的 <code>string</code>。</li><li><strong>null</strong>：即 JavaScript 的 <code>null</code>。</li><li><strong>array</strong>：使用 JavaScript 的数组表示法 <code>[]</code>。</li><li><strong>object</strong>：使用 JavaScript 的对象表示法 <code>&#123; ... &#125;</code>。</li></ul><h2 id="JSON-转换方法"><a href="#JSON-转换方法" class="headerlink" title="JSON 转换方法"></a>JSON 转换方法</h2><h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify"></a><code>JSON.stringify</code></h3><p><code>JSON.stringify</code> 方法用于将 JavaScript 对象转换为 JSON 字符串。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(value[, replacer [, space]])</span><br></pre></td></tr></table></figure><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><strong>value</strong>：要序列化成 JSON 字符串的值。</li><li><strong>replacer</strong>（可选）：<ul><li>如果是函数，则每个属性都会经过该函数的转换和处理。</li><li>如果是数组，则只有包含在这个数组中的属性名才会被序列化。</li><li>如果为 <code>null</code> 或未提供，则对象的所有属性都会被序列化。</li></ul></li><li><strong>space</strong>（可选）：<ul><li>指定缩进用的空白字符串，用于美化输出（pretty-print）。</li><li>如果参数是个数字，它代表有多少的空格；上限为 10。</li><li>如果参数为字符串（当字符串长度超过 10 个字母，取其前 10 个字母），该字符串将被作为空格。</li><li>如果该参数没有提供（或者为 <code>null</code>），将没有空格。</li></ul></li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">14</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">1.65</span>,</span><br><span class="line">    <span class="attr">grade</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&#x27;middle-school&#x27;</span>: <span class="string">&#x27;&quot;W3C&quot; Middle School&#x27;</span>,</span><br><span class="line">    <span class="attr">skills</span>: [<span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Lisp&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(xiaoming, <span class="literal">null</span>, <span class="string">&#x27;  &#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br></pre></td></tr></table></figure><h3 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse"></a><code>JSON.parse</code></h3><p><code>JSON.parse</code> 方法用于将 JSON 字符串转换为 JavaScript 对象。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(text[, reviver])</span><br></pre></td></tr></table></figure><ul><li><strong>text</strong>：要解析的 JSON 字符串。</li><li><strong>reviver</strong>（可选）：一个函数，用来转换解析出的键值对。</li></ul><h2 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h2><p>下面是一个从 API 获取天气信息并将其转换为 JSON 格式的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="string">&#x27;https://api.openweathermap.org/data/2.5/forecast?q=Xian,cn&amp;appid=800f49846586c3ba6e7052cfc89af16c&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(url)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">resp</span> =&gt;</span> resp.<span class="title function_">json</span>())</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> info = &#123;</span><br><span class="line">            <span class="attr">city</span>: data.<span class="property">city</span>.<span class="property">name</span>,</span><br><span class="line">            <span class="attr">weather</span>: data.<span class="property">list</span>[<span class="number">0</span>].<span class="property">weather</span>[<span class="number">0</span>].<span class="property">main</span>,</span><br><span class="line">            <span class="attr">time</span>: data.<span class="property">list</span>[<span class="number">0</span>].<span class="property">dt_txt</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(info, <span class="literal">null</span>, <span class="string">&#x27;  &#x27;</span>));</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>这段代码通过调用 OpenWeatherMap API 获取西安的天气预报数据，并提取城市名称、当前天气状况和时间信息</p>]]></content>
    
    
    <summary type="html">javascript中的json处理一些方法</summary>
    
    
    
    <category term="js" scheme="https://wilsssssssson.github.io/categories/js/"/>
    
    
    <category term="js" scheme="https://wilsssssssson.github.io/tags/js/"/>
    
    <category term="JSON" scheme="https://wilsssssssson.github.io/tags/JSON/"/>
    
  </entry>
  
</feed>
